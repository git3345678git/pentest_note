cryptographyintro

-----------------------------------------------------------------------

gpg --symmetric --cipher-algo CIPHER message.txt

加密的文件將另存為message.txt.gpg.


你提供的 GPG 命令是用于对文件进行对称加密的。以下是你命令中使用的参数的解释：

- `--symmetric`: 这个参数指定对称加密。对称加密使用相同的密钥进行加密和解密，相较于非对称加密来说更简单，但需要确保密钥的安全传递。

- `--cipher-algo CIPHER`: 这个参数用于指定加密时使用的密码算法。在你的命令中，"CIPHER" 应该被替换为实际的密码算法名称，例如 AES、CAST5、3DES 等。你需要选择一个安全的密码算法。

- `message.txt`: 这是要加密的文件的文件名。在你的命令中，它指定了一个名为 "message.txt" 的文件。你可以将其替换为要加密的实际文件的路径和名称。

最后的 "是" 不是 GPG 命令的一部分，它可能是一个意外或误输入的字符。

如果你有任何进一步的问题，或者需要关于特定参数的更详细解释，请告诉我。


解密：
gpg --output original_message.txt --decrypt message.gpg

-----------------------------------------------------------------------





openssl aes-256-cbc -e -in message.txt -out encrypted_message

openssl aes-256-cbc -d -in encrypted_message -out original_message.txt




為了使加密更加安全並且能夠抵抗暴力攻擊，我們可以添加-pbkdf2使用基於密碼的密鑰導出函數2（PBKDF2）；此外，我們可以指定密碼的迭代次數以使用 匯出加密金鑰-iter NUMBER。要迭代 10,000 次，先前的命令將變為：

openssl aes-256-cbc -pbkdf2 -iter 10000 -e -in message.txt -out encrypted_message



因此，解密命令變為：
openssl aes-256-cbc -pbkdf2 -iter 10000 -d -in encrypted_message -out original_message.txt

-----------------------------------------------------------------------


gpg 解密 quote01.txt.gpg 文件中的第三個單字是什麼？ (密碼:s!kR3T55)


gpg --decrypt  --passphrase 's!kR3T55' -o quote01.txt quote01.txt.gpg  

awk '{print $3}' quote01.txt

//waste
-----------------------------------------------------------------------


openssl aes-256-cbc -d -in quote02 -out original_message.txt -k 's!kR3T55'

awk '{print $3}' original_message.txt

//science
-----------------------------------------------------------------------


gpg --decrypt --cipher-algo CAMELLIA256  -o original_message.txt quote03.txt.gpg

//understand
-----------------------------------------------------------------------


非對稱加密

如果 Alice 使用 Bob 的公鑰加密訊息，則只能使用 Bob 的私鑰對其進行解密。
相反，如果鮑伯使用他的私鑰加密訊息，則只能使用鮑伯的公鑰對其進行解密。


RSA 安全性依賴因式分解，這是一個難題。將p乘以q很容易；然而，在給定N的情況下找到p和q非常耗時。此外，為了確保安全，p和q應該是相當大的數字，例如，每個都是 1024 位元（這是一個超過 300 位的數字）。值得注意的是，與其他非對稱加密演算法一樣，RSA 依賴安全隨機數產生。如果對手可以猜測p和q，整個系統將被認為是不安全的。




我們用來genrsa產生 RSA 私鑰。使用-out，我們指定將產生的私鑰保存為private-key.pem. 我們新增了2048指定 2048 位元金鑰大小的內容:

openssl genrsa -out private-key.pem 2048



使用 RSA 演算法rsa。將私鑰設為輸入-in private-key.pem 產生公鑰:

openssl rsa -in private-key.pem -pubout -out public-key.pem


---------------------------------------------------------------

openssl rsa -in private-key.pem -text -noout：

-text -noout. 查看RSA 變量，

p:  prime1
q:  prime2
N:  modulus
e:  publicExponent
d:  privateExponent
---------------------------------------------------------------




Bob 收到Alice 發送給他的文件 ciphertext_message

資料夾有已下文件

public-key-bob.pem

public-key-alice.pem

private-ke-bob.pem




看起來，Bob 收到了由 Alice 發送的加密訊息（`encrypt_message`）。在這個情境下，Alice 和 Bob 各自擁有一對公鑰和私鑰。由於是加密訊息，我們可以推測 Alice 使用 Bob 的公鑰進行加密，這樣只有 Bob 的私鑰能夠解密該訊息。

解密流程：

1. **使用 Bob 的私鑰解密訊息：**
   - Bob 擁有 `private-key_bob.pem`，他可以使用這個私鑰對收到的加密訊息進行解密。

2. **使用 Alice 的公鑰確認簽名（如果有的話）：**
   - 如果 Alice 在訊息中包含了數位簽名，Bob 可以使用 Alice 的公鑰來驗證簽名的有效性。這樣可以確保訊息確實是由 Alice 所發送，而且沒有被竄改。





看起來，Bob 收到了由 Alice 發送的加密訊息（`encrypt_message`）。在這個情境下，Alice 和 Bob 各自擁有一對公鑰和私鑰。由於是加密訊息，我們可以推測 Alice 使用 Bob 的公鑰進行加密，這樣只有 Bob 的私鑰能夠解密該訊息。


用 bob 私鑰解密
openssl pkeyutl -decrypt -in ciphertext_message -inkey  private-key-bob.pem -out decrypted.txt


查看查看RSA 變量，
openssl rsa -in private-key-bob.pem -text -noout





-----------------------------------------------------------------------

迪菲-赫爾曼密鑰交換



 openssl dhparam -out dhparams.pem 2048


openssl dhparam -in dhparams.pem -text -noout

-----------------------------------------------------------------------


加密雜湊函數
它採用任意大小的資料作為其輸入，並傳回固定大小的值


有很多用途，特別是：

儲存密碼：不是以明文儲存密碼，而是儲存密碼的雜湊值。因此，如果發生資料洩露，攻擊者將獲得密碼雜湊列表而不是原始密碼。（實際上，密碼也被“加鹽”，如後面的任務中所述。）


檢測修改：對原始檔案的任何微小修改都會導致雜湊值（即校驗和）發生巨大變化。


一些正在使用且仍被認為安全的雜湊演算法是：

SHA224、SHA256、SHA384、SHA512
成熟的MD160



一些較舊的雜湊函數，例如 MD5（訊息摘要 5）和 SHA-1，在密碼學上已被破壞。所謂損壞，是指可以產生與給定檔案具有相同校驗和的不同檔案。這意味著我們可以創建哈希衝突。換句話說，攻擊者可以使用給定的校驗和建立新訊息，並且無法偵測檔案或訊息篡改。


-----------------------------------------------------------------------



HMAC 是除了雜湊函數之外還使用加密金鑰的訊息認證碼 (MAC)

要在 Linux 系統上計算 HMAC，您可以使用任何可用的工具，例如hmac256（或sha224hmac、sha256hmac、sha384hmac和sha512hmac，其中金鑰會新增在選項之後--key）。hmac256下面我們展示了使用和sha256hmac兩個不同金鑰計算 HMAC 的範例。




sha256sum order.json
//2c34b68669427d15f76a1c06ab941e3e6038dacdfb9209455c87519a3ef2c660


sha256sum New_order.json
/11faeec5edc2a2bad82ab116bbe4df0f4bc6edd96adac7150bb4e6364a238466


hmac256  3RfDFz82 order.txt
//c7e4de386a09ef970300243a70a444ee2a4ca62413aeaeb7097d43d2c5fac89f

-----------------------------------------------------------------------



coding.tools -> E1 -> ISRG Root X2


1. **最頂層的憑證（Root Certificate）：ISRG Root X2**
   - `ISRG Root X2` 是一個由 Internet Security Research Group（ISRG）簽署的根憑證，也是 Let's Encrypt CA 使用的根憑證之一。根憑證是憑證鏈中的最高級別，通常內置在操作系統和瀏覽器中。

2. **中間憑證（Intermediate Certificate）：E1**
   - `E1` 是由 Let's Encrypt 簽署的中間憑證。這個中間憑證是用來連接根憑證和伺服器憑證的。中間憑證的存在有助於保證根憑證的安全，因為根憑證通常存儲在更安全的位置，而中間憑證則可能更容易被更換。

3. **伺服器憑證：coding.tools**
   - `coding.tools` 是伺服器憑證的 Common Name（通常是域名）。這是由 Let's Encrypt 簽署的憑證，並且在這個特定的例子中，它是網站 `coding.tools` 的憑證。

當瀏覽器建立到網站 `coding.tools` 的連接時，它會檢查伺服器提供的憑證鏈。瀏覽器會確保根憑證 `ISRG Root X2` 是由瀏覽器信任的 CA（可能是操作系統或瀏覽器預先內置的），而中間憑證 `E1` 是由根憑證簽署的。最後，伺服器憑證 `coding.tools` 是由中間憑證簽署的。

這樣的憑證鏈確保了數據在客戶端和伺服器之間的加密，並且客戶端可以信任伺服器的身份。


-----------------------------------------------------------------------

如果您的瀏覽器只顯示了 `ISRG Root X1`，而沒有 `ISRG Root X2`，這可能是因為 `ISRG Root X2` 的根憑證尚未被您的瀏覽器內置或更新。

`ISRG Root X1` 和 `ISRG Root X2` 是 Let's Encrypt 使用的兩個根憑證，它們的存在是為了提供冗餘和可用性。瀏覽器和操作系統通常定期更新根憑證，以確保信任鏈的有效性。

如果您的瀏覽器沒有顯示 `ISRG Root X2`，您可以考慮進行以下操作：

1. **檢查瀏覽器更新：** 確保您的瀏覽器是最新版本。瀏覽器通常會在更新中包含新的根憑證。

2. **操作系統更新：** 有時，操作系統的根憑證存儲庫也需要更新。確保您的操作系統也是最新的。

3. **手動安裝 `ISRG Root X2`：** 如果您希望手動安裝 `ISRG Root X2`，您可以訪問 Let's Encrypt 的官方網站，那裡通常會提供憑證的下載鏈接。

請注意，即使瀏覽器未顯示 `ISRG Root X2`，只要 `ISRG Root X1` 是受信任的，憑證鏈仍然應該有效。`ISRG Root X2` 主要是用作 `ISRG Root X1` 的備份。


-----------------------------------------------------------------------


作為 coding.tools 的管理者，您可以按照以下步驟申請並安裝 SSL/TLS 憑證，以確保您的網站在瀏覽器中建立安全的 HTTPS 連接：

選擇憑證授權機構（CA）：

選擇一個受信任的憑證授權機構，例如 Let's Encrypt、Comodo、GlobalSign 等。Let's Encrypt 提供免費的 SSL/TLS 憑證，並且受到廣泛信任。
生成憑證簽署請求（CSR）：

在您的伺服器上生成一個 CSR，其中包含有關您網站和組織的信息，以及您的公開金鑰。這可以使用 OpenSSL 或您伺服器所使用的其他工具進行。
提交 CSR 至 CA：

將生成的 CSR 提交給您選擇的憑證授權機構。這通常可以在 CA 的網站上進行。在 Let's Encrypt 的情況下，他們提供了 Certbot 工具，可以自動處理這一步驟。
通過 CA 驗證：

CA 可能會要求您進行某種形式的域名驗證或組織驗證，以確保您擁有該網域並且有權獲得憑證。這可能涉及在您的網站上添加特定的檔案或 DNS 記錄。
獲取憑證：

完成驗證後，您將從 CA 那裡獲得 SSL/TLS 憑證。通常，憑證將包括伺服器憑證、中間憑證和根憑證。
安裝憑證：

根據您的伺服器類型，將獲得的憑證安裝到伺服器上。這可能涉及配置伺服器以使用新的憑證文件。
更新憑證：

SSL/TLS 憑證通常有一個有效期，請確保在憑證過期之前及時更新。
一旦您的網站憑證安裝並運行，訪問者將能夠通過 HTTPS 安全地連接到您的網站。瀏覽器會顯示綠色的鎖圖標，表示連接是安全的。


-----------------------------------------------------------------------

產生CSR 檔案
openssl req -new -nodes -newkey rsa:4096 -keyout key.pem -out cert.csr

req -new建立新的憑證簽署請求
-nodes保存沒有密碼的私鑰
-newkey產生新的私鑰
rsa:4096產生大小為 4096 位元的 RSA 金鑰
-keyout指定儲存密鑰的位置
-out儲存憑證簽署請求


-----------------------------------------------------------------------
openssl req -x509 -newkey -nodes rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 365

這個 OpenSSL 命令是用來生成一對 RSA 金鑰（公開金鑰和私有金鑰），同時創建一個自簽的 X.509 憑證（通常用於 TLS/SSL 加密）。

這是該命令的一些參數解釋：

- `req`: 表示使用 OpenSSL 中的 req 工具，用於憑證請求和生成。
- `-x509`: 表示要生成一個自簽的 X.509 憑證，而不是憑證請求。
- `-newkey rsa:4096`: 表示生成一對 RSA 金鑰，其中 4096 位是金鑰的位元組大小。
- `-nodes`: 表示不使用密碼對私有金鑰進行加密。如果省略此選項，您將需要在生成憑證時提供密碼。
- `-keyout key.pem`: 表示將生成的私有金鑰保存到名為 `key.pem` 的文件中。
- `-out cert.pem`: 表示將生成的 X.509 憑證保存到名為 `cert.pem` 的文件中。
- `-sha256`: 表示使用 SHA-256 散列算法簽署憑證。
- `-days 365`: 表示憑證的有效期為 365 天，即一年。

因此，當您運行這個命令時，它會生成一對 RSA 金鑰，將私鑰保存到 `key.pem` 中，然後使用該金鑰生成一個自簽的 X.509 憑證，並將該憑證保存到 `cert.pem` 中。此憑證將在 365 天內有效，使用 SHA-256 進行簽署。

-----------------------------------------------------------------------

查看憑證
openssl x509 -in cert.pem -text


公鑰的大小（以位元為單位）是多少？
4096

該證書的有效期限到哪一年？
2039

-----------------------------------------------------------------------