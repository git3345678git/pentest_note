# cryptographyintro




## 對稱加密

對稱加密是一種加密技術，其中使用相同的密鑰（或稱為秘密金鑰）來進行加密和解密。這意味著發送方和接收方必須共享相同的密鑰，並且該密鑰必須在安全的通道上進行傳輸，以防止第三方獲取該密鑰。對稱加密速度通常較快，但密鑰管理可能是一個挑戰。

在對稱加密中，常見的算法包括：

1. **AES（Advanced Encryption Standard）：** 目前被廣泛用於許多應用領域的對稱加密算法，其具有高度的安全性和效能。

2. **DES（Data Encryption Standard）：** 一個較舊的標準，已經被AES所取代，但仍然可能在某些環境中被使用。



在使用對稱加密時，要確保密鑰的安全性非常重要，因為一旦密鑰泄漏，攻擊者就能夠解密所有使用該密鑰加密的資料。密鑰的安全性通常是透過安全的金鑰管理和分發方式以及定期更換密鑰的措施來確保的。





## 以下是 GPG (GnuPG) 2.37.7 支援的對稱加密演算法列表

GNU Privacy Guard（GPG）是一個開源的加密軟件套件，
實現了OpenPGP（Open Pretty Good Privacy）標準。
OpenPGP是一個用於保護電子通信隱私的標準，包括加密和數字簽名等功能。


1. **AES（高級加密標準）：**
   - **AES-128：** 使用128位金鑰。
   - **AES-192：** 使用192位金鑰。
   - **AES-256：** 使用256位金鑰。
   - **描述：** 是一種被廣泛使用並被認為安全的對稱加密算法，由美國國家標準技術研究所（NIST）指定。

2. **IDEA（國際數據加密算法）：**
   - **金鑰尺寸：** 未指定，但通常使用128位金鑰。
   - **描述：** IDEA是一種對稱密鑰區塊加密算法，以其簡單性和高效性而聞名。它曾經被廣泛使用，但近年來像AES這樣的算法更受歡迎。

3. **3DES（三重DES）：**
   - **金鑰尺寸：** 通常使用168位金鑰（三個56位金鑰）。
   - **描述：** 3DES是一種基於DES的對稱加密算法，對每個數據塊應用DES算法三次。正如前面提到的，由於安全性問題，它正在被淘汰並將於2024年被禁止使用。

4. **CAST5（也稱為CAST-128）：**
   - **金鑰尺寸：** 128位。
   - **描述：** CAST5或CAST-128是由Carlisle Adams和Stafford Tavares設計的對稱密鑰區塊加密算法。以其簡單性和安全性而聞名。

5. **BLOWFISH：**
   - **金鑰尺寸：** 可變（最多448位）。
   - **描述：** 由Bruce Schneier設計，Blowfish是一種對稱密鑰區塊加密算法，因其速度和安全性而廣泛使用。雖然它在當今不如以前那麼普遍，但它奠定了Twofish等其他算法的基礎。

6. **TWOFISH：**
   - **金鑰尺寸：** 可變（最多256位）。
   - **描述：** 也由Bruce Schneier設計，Twofish是從Blowfish派生的對稱密鑰區塊加密算法。它是AES選擇過程的入圍者之一，雖然最終未被選中，但仍然是一種安全的算法。

7. **CAMELLIA（卡梅利亞）：**
   - **CAMELLIA128：** 使用128位金鑰。
   - **CAMELLIA192：** 使用192位金鑰。
   - **CAMELLIA256：** 使用256位金鑰。
   - **描述：** 由日本三菱電機和NTT設計，Camellia是一種對稱密鑰區塊加密算法，以其安全性和效率而聞名。




```
gpg --version

Supported algorithms:
Pubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSA
Cipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,
        CAMELLIA128, CAMELLIA192, CAMELLIA256
Hash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224
Compression: Uncompressed, ZIP, ZLIB, BZIP2

```


這兩個命令都是使用 GPG 對文件 `message.txt` 進行對稱加密，並選擇了 AES 作為加密算法。

1. **`gpg --symmetric --cipher-algo AES message.txt`：**
   - 這個命令將 `message.txt` 文件使用對稱加密算法 AES 進行加密。
   - GPG 會提示您輸入密碼，這個密碼將用於加密和稍後解密該文件。
   - 加密後的文件可能會在同一目錄中生成，或者您可以選擇輸出的文件位置。

2. **`gpg --armor --symmetric --cipher-algo AES message.txt`：**
   - 這個命令與上一個命令相似，但添加了 `--armor` 選項，它將加密輸出轉換為ASCII文本形式。
   - 加密後的ASCII文本文件可能包含在 `message.txt.asc` 或類似的文件中（根據GPG的預設行為）。

請注意，這兩個命令執行後，GPG 會提示您輸入密碼，並可能要求您再次確認密碼。這個密碼是保護您的加密文件的關鍵，因此請選擇一個強且安全的密碼。


您可以使用以下命令解密：
```

gpg --output original_message.txt --decrypt message.txt.gpg
gpg --output original_message.txt --decrypt message.txt.asc
```




## OpenSSL 項目

我們可以使用以下命令使用 OpenSSL 加密檔案：

```
openssl aes-256-cbc -e -in message.txt -out encrypted_message
```

我們可以使用以下命令解密結果檔：

```
openssl aes-256-cbc -d -in encrypted_message -out original_message.txt
```


為了使加密更加安全並且能夠抵抗暴力攻擊，我們可以添加-pbkdf2使用基於密碼的密鑰導出函數2（PBKDF2）；此外，我們可以指定密碼的迭代次數以使用 匯出加密金鑰-iter NUMBER。要迭代 10,000 次，先前的命令將變為：


```
openssl aes-256-cbc -pbkdf2 -iter 10000 -e -in message.txt -out encrypted_message
加密

openssl aes-256-cbc -pbkdf2 -iter 10000 -d -in encrypted_message -out original_message.txt
解密

```


**本題解答**
```
gpg --output original_message.txt --decrypt quote01.txt.gpg


openssl aes-256-cbc -d -in quote02 -out original_message.txt


gpg --output original_message.txt --decrypt quote03.txt.gpg
```


## 非對稱加密


非對稱加密（或稱為公開金鑰加密）通信過程涉及兩個主要的金鑰：公鑰和私鑰。以下是一個簡單的非對稱加密通信過程的基本步驟：

1. **金鑰對生成：**
   - 兩個通信方，假設為 Alice 和 Bob，各自生成一對非對稱金鑰（公鑰和私鑰）。
   - Alice 保留自己的私鑰，並將她的公鑰分享給 Bob。同樣，Bob 保留自己的私鑰，並將他的公鑰分享給 Alice。

2. **加密消息：**
   - Alice 想要將一條消息發送給 Bob。她使用 Bob 的公鑰進行加密，這樣只有擁有 Bob 的私鑰的人才能解密該消息。
   - Alice 使用 Bob 的公鑰將消息加密，然後發送給 Bob。

3. **解密消息：**
   - Bob 收到由 Alice 加密的消息。為了解密它，他使用自己的私鑰，因為只有擁有相應私鑰的人才能解密由公鑰加密的消息。
   - Bob 使用他的私鑰解密消息，得到原始的、可讀的內容。

這樣的非對稱加密通信過程確保了傳輸的數據在傳輸過程中是安全的。即使有人截獲了由 Alice 發送給 Bob 的加密消息，由於只有 Bob 擁有私鑰，其他人無法解密該消息。

需要注意的是，非對稱加密在實際通信中通常與對稱加密結合使用，以提高效能。通常，用來保護通信的對稱金鑰將使用非對稱加密的方式進行傳遞。當然，具體的實現可能會根據應用程序的要求和協議的選擇而有所不同。




```
產生 RSA 私鑰
openssl genrsa -out private-key.pem 2048

提取 RSA 公鑰
openssl rsa -in private-key.pem -pubout -out public-key.pem

查看RSA私鑰變量
openssl rsa -in private-key.pem -text -noout



p、q、N、e和d的值分別為prime1、prime2、modulus、publicExponent和privateExponent。


```



如果我們已經有了收件者的公鑰，我們可以使用以下命令對其進行加密
```
openssl pkeyutl -encrypt -in plaintext.txt -out ciphertext -inkey public-key.pem -pubin

pkeyutl：OpenSSL 中的工具，用於操作公鑰和私鑰。
-encrypt：指定使用加密操作。
-in plaintext.txt：指定要加密的輸入文件，這裡是 plaintext.txt。
-out ciphertext：指定加密後的輸出文件，這裡是 ciphertext。
-inkey public-key.pem：指定公鑰的輸入文件，這裡是 public-key.pem。
-pubin：表示輸入的金鑰是一個公鑰。


```

接收者可以使用命令解密
```
openssl pkeyutl -decrypt -in ciphertext -inkey private-key.pem -out decrypted.txt


pkeyutl：OpenSSL 中的工具，用於操作公鑰和私鑰。
-decrypt：指定使用解密操作。
-in ciphertext：指定要解密的輸入文件，這裡是 ciphertext，這是使用公鑰加密的文件。
-inkey private-key.pem：指定私鑰的輸入文件，這裡是 private-key.pem。
-out decrypted.txt：指定解密後的輸出文件，這裡是 decrypted.txt。


```


**解答**
```
openssl pkeyutl -decrypt -in ciphertext_message -inkey private-key-bob.pem -out decrypted.txt

openssl rsa -in private-key-bob.pem -text -noout
```







## 迪菲-赫爾曼（Diffie-Hellman）密鑰交換

是一種公開金鑰密碼學協議，用於在通信雙方之間安全地交換密鑰。它允許雙方在不傳送密鑰的情況下協商共享的密鑰。以下是簡要的迪菲-赫爾曼密鑰交換過程：


1. **參與者生成公鑰和私鑰：**
   - 每個通信參與者生成一對公鑰和私鑰。
   - 公鑰可以公開分享，私鑰則保密。

2. **交換公鑰：**
   - 各方將自己的公鑰發送給對方，這可以通過不安全的通道進行，因為公鑰本身並不用於加密敏感信息。

3. **計算共享密鑰：**
   - 各方使用對方發送的公鑰和自己的私鑰計算一個共享的密鑰。由於迪菲-赫爾曼的數學性質，雙方計算出的共享密鑰是相同的，即使在公共通信渠道上傳輸的公鑰被截獲也無法推斷私鑰。

整個過程的安全性基於數學難題，即計算離散對數的困難性。即使攻擊者截獲了公鑰，也很難從公鑰計算出對應的私鑰。

在實際應用中，迪菲-赫爾曼密鑰交換常用於建立安全通信通道的初始階段，然後通常配合對稱加密算法使用共享的密鑰以保護實際的通信內容。



```
生成 Diffie-Hellman 參數
openssl dhparam -out dhparams.pem 2048

查看 Diffie-Hellman 參數的詳細信息
openssl dhparam -in dhparams.pem -text -noout
```


## 散列

加密雜湊函數是一種演算法，它採用任意大小的資料作為其輸入，並傳回固定大小的值

一些較舊的雜湊函數，例如MD5（訊息摘要 5）和 SHA-1，在密碼學上已被破壞

一些正在使用且仍被認為安全的雜湊演算法是：
SHA224, SHA256, SHA384, SHA512, RIPEMD160


### HMAC 是除了雜湊函數之外還使用加密金鑰的訊息認證碼（MAC）。

* 金鑰
* 內墊 (ipad) 一個常數字串。（RFC2104 使用重複 B 次的位元組0x36。B 的值取決於所選的雜湊函數。）
* 外部 pad (opad) 一個常數字串。（RFC2104 使用重複 B 次的位元組0x5C。）

範例
```
user@TryHackMe$ hmac256 s!Kr37 message.txt
3ec65b7e80c5bf2e623e52e0528f1c6a74f605b10616621ba1c22a89fb244e65  message.txt

user@TryHackMe$ hmac256 1234 message.txt
4b6a2783631180fca6128592e3d17fb5bff6b0e563ad8f1c6afc1050869e440f  message.txt

user@TryHackMe$ sha256hmac message.txt --key s!Kr37
3ec65b7e80c5bf2e623e52e0528f1c6a74f605b10616621ba1c22a89fb244e65  message.txt

user@TryHackMe$ sha256hmac message.txt --key 1234
4b6a2783631180fca6128592e3d17fb5bff6b0e563ad8f1c6afc1050869e440f  message.txt
```





解答
```
sha256sum order.json
//2c34b68669427d15f76a1c06ab941e3e6038dacdfb9209455c87519a3ef2c660


sha256sum New_order.json
/11faeec5edc2a2bad82ab116bbe4df0f4bc6edd96adac7150bb4e6364a238466


hmac256  3RfDFz82 order.txt
//c7e4de386a09ef970300243a70a444ee2a4ca62413aeaeb7097d43d2c5fac89f
```



## PKI 和 SSL/TLS


### 公鑰基礎設施（PKI）


考慮一下您透過 HTTPS 瀏覽網站example.org的情況。您如何確信您確實正在與example.org伺服器通訊

對於由證書頒發機構簽署的證書，我們需要

1. 產生憑證簽署請求 (CSR)：您建立憑證並將公鑰傳送給第三方進行簽署。
2. 將您的 CSR 發送給憑證授權單位 (CA)：目的是讓 CA 簽署您的憑證。

* 另一種通常不安全的解決方案是對憑證進行自簽名。


**產生憑證簽署請求CSR**
```
openssl req -new -nodes -newkey rsa:4096 -keyout key.pem -out cert.csr。我們使用了以下選項：

req: 使用 OpenSSL 的 CSR 與憑證請求相關工具。
-new: 創建一個新的憑證請求。
-nodes: 不加密生成的私鑰，使私鑰無密碼保護。
-newkey rsa:4096: 創建一對 RSA 4096 位的公私鑰。
-keyout key.pem: 指定私鑰輸出的文件為 key.pem。
-out cert.csr: 指定 CSR 輸出的文件為 cert.csr。
```


**生成自簽名憑證**
```
openssl req -x509 -newkey -nodes rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 365

req: 使用 OpenSSL 的 CSR 與憑證請求相關工具。
-x509: 創建一個 X.509 憑證，而不是 CSR。
-newkey rsa:4096: 創建一對 RSA 4096 位的公私鑰。
-nodes: 不加密生成的私鑰，使私鑰無密碼保護。
-keyout key.pem: 指定私鑰輸出的文件為 key.pem。
-out cert.pem: 指定憑證輸出的文件為 cert.pem。
-sha256: 使用 SHA-256 作為摘要算法。
-days 365: 設定憑證的有效期為 365 天。
```


### 我們想探索當我們透過 HTTPS 登入網站時會發生什麼。

1. **客戶端請求伺服器的 SSL/TLS 憑證：**
   - 在 SSL/TLS 握手過程的一部分，客戶端將要求伺服器提供其數字憑證。

2. **伺服器傳送 SSL/TLS 憑證：**
   - 伺服器將其憑證和相關信息（如公開金鑰）傳送給客戶端。

3. **用戶端確認憑證有效：**
   - 客戶端使用內建的或事先安裝的根憑證（trusted root certificates）列表來驗證伺服器提供的憑證的有效性。
   - 驗證包括檢查憑證的簽發者是否在根憑證列表中，憑證是否在有效期內，以及憑證的基本條件是否符合要求（例如主題名稱）。

4. **憑證簽名的作用：**
   - 憑證簽名是使用憑證簽發者的私鑰對憑證的內容進行加密的過程。這樣的簽名允許檢查憑證是否未被篡改。
   - 客戶端使用根憑證中相對應的公鑰解密憑證的簽名，然後比較解密的哈希值是否與憑證本身的哈希值一致。

5. **第三方憑證的辨識：**
   - 如果客戶端能夠辨識並信任簽發憑證的第三方（憑證簽發者），則驗證成功，並且SSL/TLS 通信繼續。
   - 如果客戶端無法辨識或信任第三方，則連線可能會被中止，或者客戶端可能會發出警告。

6. **信任的根憑證：**
   - 信任的根憑證通常是瀏覽器或應用程式內建的，也可以由用戶或系統管理員事先安裝。

這個過程確保了通信雙方的身份和數據的完整性。如果憑證的簽發者被信任，則可以確保通信是安全的。如果憑證的簽發者無法被信任，則客戶端可能會拒絕與伺服器建立安全連線。